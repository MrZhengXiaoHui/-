<!-- TOC -->

- [前端](#前端)
    - [html](#html)
    - [css](#css)
    - [javascript](#javascript)
    - [es6+](#es6)
    - [异步](#异步)
    - [手写代码](#手写代码)
    - [虚拟DOM (virtual dom)](#虚拟dom-virtual-dom)
    - [vue](#vue)
    - [react](#react)
    - [vue和react对比](#vue和react对比)
    - [webpack](#webpack)
    - [小程序](#小程序)
    - [hybrid](#hybrid)
    - [TypeScript](#typescript)
    - [web存储](#web存储)
    - [设计模式 (常用的几个)](#设计模式-常用的几个)
    - [算法题](#算法题)
    - [浏览器相关的一些问题](#浏览器相关的一些问题)
    - [安全防范知识点](#安全防范知识点)
    - [性能优化](#性能优化)
    - [网络](#网络)
    - [了解数据结构](#了解数据结构)

<!-- /TOC -->

# 前端

## html

> Doctype是什么？

- 用于告知浏览器以何种模式来渲染文档

> html语义化是什么？

- 当页面样式加载失败的时候能够让页面呈现出清晰的结构
- 有利于seo优化，利于被搜索引擎收录
- 便于项目的开发及维护，使html代码更具有可读性，便于其他设备解析

> 行内元素、块级元素？

- 行内元素：a、b、i、span、input等
- 块级元素：div、p、h1~h6、form等

> src和href的区别是什么？

- src：指向外部资源的位置，指向的内容将会嵌入文档中当前标签所在的位置。当浏览器解析到该元素时，会暂停其他资源的下载和处理
- href：指向网络资源的位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。当浏览器解析到该元素时，会并行下载资源并且不会停止对当前文档的处理

> iframe有那些缺点？

- 会阻塞主页面的onload事件
- 即使内容为空，加载也需要时间
- 没有语义

> html5常用新标签

- `<nav>` 表示导航
- `<header>` 表示页眉
- `<footer>` 表示页脚
- `<section>` 表示区块
- `<aside>` 表示侧边栏

## css

> 常用页面布局

- 三栏布局（三栏布局两侧宽度固定不变，中间部分自动填充整个区域）
    - (1) 定位
        ```html
            <!-- 外层一个div盒子包裹三个子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
                <div class="right">3</div>
            </div>
        ```
        ```css
            /* 
                外层盒子相对定位，
                内层左右盒子固定宽度且绝对定位，
                内层中间盒子宽度100%，内边距设置成左右盒子的宽度值，并设置box-sizing: border-box;改变盒模型
            */
            .box{
                width: 100%;
                height: 100%;
                position: relative;
            }
            
            .left {
                width: 200px;
                background-color: antiquewhite;
                position: absolute;
                top: 0;
                left: 0;
            }

            .right {
                width: 200px;
                background-color: antiquewhite;
                position: absolute;
                top: 0;
                right: 0;
            }

            .center {
                width: 100%;
                background-color: burlywood;
                padding: 0 200px;
                box-sizing: border-box;
            }
        ```
    - (2) flex
         ```html
            <!-- 外层一个div盒子包裹三个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
                <div class="right">3</div>
            </div>
        ```
        ```css
            /*
                外层盒子设置display: flex;
                内层盒子左右固定宽度，中间盒子设置flex:1
            */
            .box{
                width: 100%;
                height: 100%;
                display: flex;
            }
            .left {
                width: 200px;
                background-color: antiquewhite;
            }

            .right {
                width: 200px;
                background-color: antiquewhite;
            }

            .center {
                width: 100%;
                flex: 1;
                background-color: burlywood;
            }
        ```
- 两栏布局(左侧固定右侧自适应布局)
    - (1) 定位
        ```html
            <!-- 外层一个div盒子包裹两个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
            </div>
        ```
        ```css
            /* 
                外层盒子相对定位，
                内层左盒子固定宽度且绝对定位，
                内层中间盒子宽度100%，内边距设置成左盒子的宽度值，并设置box-sizing: border-box;改变盒模型
            */
            .box {
                width: 100%;
                height: 100%;
                position: relative;
            }

            .left {
                width: 200px;
                position: absolute;
                left: 0;
                top: 0;
                background-color: antiquewhite;
            }

            .center {
                width: 100%;
                padding-left: 200px;
                box-sizing: border-box;
                background-color: burlywood;
            }
        ```
    - (2) flex
        ```html
            <!-- 外层一个div盒子包裹两个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
            </div>
        ```
        ```css
            /*
               外层盒子设置display: flex;
               内层盒子左固定宽度，中间盒子设置flex:1 
            */
            .box {
                width: 100%;
                height: 100%;
                display: flex;
            }

            .left {
                width: 200px;
                background-color: antiquewhite;
            }

            .center {
                width: 100%;
                flex: 1;
                background-color: burlywood;
            }
        ```
    - (3) 浮动
        ```html
            <!-- 外层一个div盒子包裹两个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
            </div>
        ```
        ```css
            /*
               内层盒子左固定宽度并设置左浮动，中间盒子设置左侧外边距为左盒子的宽
            */
            .box {
                width: 100%;
                height: 100%;
            }

            .left {
                width: 200px;
                float:left;
                background-color: antiquewhite;
            }

            .center {
                margin-left:200px;
                background-color: burlywood;
            }
        ```
- 上中下结构布局
    - 定位
        ```html
            <!-- 三个div盒子 -->
            <div class="header">1</div>
            <div class="container">2</div>
            <div class="footer">3</div>
        ```
        ```css
            /*
                初始化html和body样式并设置宽高为100%
                顶部盒子固定定位设置top:0
                底部盒子固定定位设置bottom：0
                中间盒子设置内边距等于顶部和底部盒子的高度值，并设置box-sizing: border-box;改变盒模型。设置最小高度为100%

            */
            html,body{
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
            }
            .header{
                width: 100%;
                height: 20px;
                background-color: #b9ffd8;
                position: fixed;
                top: 0;
                left: 0;
            }
            .container{
                width: 100%;
                min-height: 100%;
                padding: 20px 0;
                box-sizing: border-box;
                background-color: #d7ff7c;
            }
            .footer{
                width: 100%;
                height: 20px;
                position: fixed;
                bottom: 0;
                left: 0;
                background-color: #1d1d1d;
            }
        ```
- css实现垂直居中
    ```css
        .content{
            weith:200px;
            height:200px;
            /* flex
            display:flex;
            justify-content:center;
            align-items:center;
            */

            /* 定位
            position:absolute;
            top:50%;
            left:50%;
            margin-left:-100px;
            margin-top:-100px;
            */
            
            /* css3
            transform:translate(-50%,-50%);
            */
        }
        <div class="content"></div>
    ```

> BFC (块级格式化上下文)

- 从理论上讲父元素包裹的元素不会影响旁边的元素
- 官方定义
    - 它决定了元素如何对其内容进行定位 以及与其他元素的关系和相互作用 当涉及到可视化布局的时候 Block Formatting Context提供了一个环境 HTML元素在这个环境中按照一定规则进行布局
- BFC的目的是 形成一个完全独立的空间 让空间里的子元素不会影响到外面的布局
- 触发BFC (常用规则)
    1. float不为none
    2. position不为relative和static
    3. overflow为auto scroll和hidden
    4. display的值为table-cell和inline-block
- 利用BFC解决问题
    1. 解决浮动元素令父元素高度坍塌的问题
        - 假设页面里有一个父元素和几个子元素，这几个子元素都设为浮动时，父元素高度坍塌，这是因为浮动的子元素脱离了文档流，父元素检测不到它的存在无法被它撑开，这时给父元素添加属性overflow:hidden。也可以添加属性display:table-cell，或者是position:fixed等等,这些属性都是触发了BFC。触发了BFC的容器就是页面上的一个完全隔离开的容器，容器里的子元素绝对不会影响到外面的元素，为了保证这样的规则，不得不让浮动的子元素也参与进来，变相地实现了清除内部浮动的目的
        - 常用的办法
            1. 让父元素也浮动起来，这样父元素和子元素一起脱离文档流，这样父元素就能自适应子元素的高度
                - 缺点：会影响父元素之后的元素排列
            2. 给父元素添加一个固定高度
            3. 在一个浮动的子元素后面增加一个空元素，设置clear:both来清除浮动
                - 缺点：增加无意义标签，不利于维护
            4. 为浮动的最后一个子元素设置伪元素::after{clear:both}
    2. 解决自适应布局的问题
        - 两栏布局 (左侧固定，右侧自适应)
            - 左边设置float:left;width:200px。右边设置margin-left:200px
    3. 解决外边距垂直方向重合问题
        - 兄弟元素之间的外边距，在垂直方向上会取最大值而不是取和，可以通过触发BFC来防止它们之间相互影响
        - 比如为其中一个元素增加一个父元素，并触发父元素BFC，如overflow:hidden这样就不会重叠了

> flex布局 (简单的说几个常用的)

- 又称"弹性布局"
    - 容器设置display:flex;
    - 属性
        - justify-content
            1. flex-start （默认值） 左对齐
            2. flex-end 右对齐
            3. center 居中
            4. space-between 两端对齐，如果是三个及以上的盒子之间的间隔都相等
            5. space-around 两侧的会有间隔，内部间隔比两侧的间隔大一倍
        - align-items
            - center 上下居中 （配合着justify-content:center属性做垂直居中）
        - flex-wrap属性 控制是否换行
    - 其他属性参考 [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html "Flex 布局教程：语法篇")

> rem、em、px

- rem
    - 根据html的font-size属性的值 进行计算 1rem = html的font-size
- em
    - 根据当前对象内font-size属性的值 进行计算 1em = 当前对象内font-size
- px
    - 像素。相对于显示器屏幕分辨率


> less、sass/scss

- 都是动态样式语言 css的超集
- 变量符不一样，Less是@，而Scss是$
- 编译环境不一样。Sass的安装需要Ruby环境，是在服务端处理的，Less 可以运行在 Node 或浏览器端
- Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。

> 为什么用sass或less？

- 有动态语言的特性，可以定义变量、运算等
- 结构清晰，便于扩展
- 可以实现继承
- 完全兼容css代码

> 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？

- 标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin
- 低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin

> CSS优先级算法如何计算？

- 元素选择符： 1
- class选择符： 10
- id选择符：100
- 元素标签：1000
- !important声明的样式优先级最高，如果冲突再进行计算。
- 如果优先级相同，则选择最后出现的样式。
- 继承得到的样式的优先级最低。

> display有哪些值？

- display: inline 内联
- display: none 隐藏
- display: block 块元素
- display: table 表格显示
- display: list-item 项目列表
- display: inline-block 行内元素

> position的值

- static（默认）：按照正常文档流进行排列；
- relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；
- absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；
- fixed(固定定位)：所固定的参照对像是可视窗口。

> css实现三角形

```css
    div{
        width: 0;
        height: 0;
        border-top: 40px solid transparent;
        border-left: 40px solid transparent;
        border-right: 40px solid transparent;
        border-bottom: 40px solid #ff0000;
    }
```

> 文字溢出实现...的效果

```css
    // 单行溢出
    div{
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        width: 90%;
    }
    // 多行溢出
    div{
        overflow: hidden;  
        text-overflow: ellipsis;  
        display: -webkit-box;  
        -webkit-line-clamp: 3;  
        -webkit-box-orient: vertical;
    }
```

> display:none与visibility：hidden的区别？

- display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）
- visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）

> Chrome浏览器默认字体大小是多少？怎么让浏览器支持小于12px的文字

- 默认大小是16px
- 让浏览器支持小于12px的字体，可以设置缩放 transform:scale(0.8)

> css3 新增的属性

- 圆角 border-radius
- 阴影 box-shadow
- 文字阴影 text-shadow
- 线性渐变 gradient
- 动画 transform
    - rotate 旋转
    - scale 缩放
    - translate 定位
    - skew 倾斜
- 背景等等

> 伪类和伪元素

- 伪类单冒号
   - p:first-of-type    选择属于其父元素的首个 p 元素的每个 p 元素。
   - p:last-of-type    选择属于其父元素的最后 p 元素的每个 p 元素。
   - p:only-of-type    选择属于其父元素唯一的 p 元素的每个 p 元素。
   - p:only-child    选择属于其父元素的唯一子元素的每个 p 元素。
   - p:nth-child(2)    选择属于其父元素的第二个子元素的每个 p 元素。
   - :enabled  :disabled 控制表单控件的禁用状态。
   - :checked        单选框或复选框被选中。
- 伪元素双冒号

## javascript

> 什么是原型

- 对象的 `__proto__` 属性指向原型

> 什么是原型链

- 就是多个对象通过 `__proto__` 的方式连接了起来

> object.prototype的属性和方法

- Object.defineProperty(parame)方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。
- Object.hasOwnProperty(parame)方法用来判断某个对象是否含有指定的自身属性。
- Object.toString()将对象转换为字符串,不同类型的对象可能会重写自己的toString方法
    - `[1,2,3].toString() // 1,2,3`  Array包含的元素使用逗号连接起来组成字符串并返回
    - Date的toString方法会返回Date的时间字符串等
    - 普通object类型对象会返回[object Object]

> js原始类型

- boolean
- null
- undefined
- number
- string
- symbol
    - 功能类似于一种标识唯一性的ID
        ```javascript
            let s1 = Symbol()
            let s2 = Symbol('another symbol')
            let s3 = Symbol('another symbol')

            s1 === s2 // false
            s2 === s3 // false
        ```
    - 使用Symbol来作为对象属性名(key)
        ```javascript
            const PROP_NAME = Symbol()
            const PROP_AGE = Symbol()

            let obj = {
            [PROP_NAME]: "一斤代码"
            }
            obj[PROP_AGE] = 18

            obj[PROP_NAME] // '一斤代码'
            obj[PROP_AGE] // 18
        ```
    - typeof检查时返回的是symbol

> 对象（Object）类型

- 对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

> typeof 是否能正确判断类型？

- typeof 对于原始类型来说，除了 null 都可以显示正确的类型
    ```javascript
        typeof 1 // 'number'
        typeof '1' // 'string'
        typeof undefined // 'undefined'
        typeof true // 'boolean'
        typeof Symbol() // 'symbol'
    ```
- typeof 对于对象来说，除了函数都会显示 object
    ```javascript
        typeof [] // 'object'
        typeof {} // 'object'
        typeof console.log // 'function'
    ```

> instanceof 能正确判断对象的原理是什么？

- 内部机制是通过原型链来判断的

> this

- 对于直接调用函数，不管函数放在哪，this一定是window
- 对于对象.函数来说，谁调用了函数，谁就是this。
- 对于new来说，this永远绑定在实例上。
- 箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this
- 给函数bind或apply或call几次，this永远由第一次bind或apply或call决定
    - this 取决于第一个参数
    - 如果第一个参数为空，那么就是 window

> == vs ===

- == 
    - 如果对比的双方不一样的话，就会进行类型转换
    - boolean会转换成1或0
    - 对象会转换成原始类型 如转换成'[object Object]'
- 如果比较的是值类型，那么“==”比较其值；“===”比较其类型与值
- 如果是引用类型，那么比较的都是地址

> 闭包

- 什么是闭包
    - 函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
    - 闭包存在的意义就是让我们可以间接访问函数内部的变量。

> 深浅拷贝

- 浅拷贝 (浅拷贝只解决了第一层的问题)
    - object.assign
        ```javascript
            let a = {
                age: 1
            }
            let b = object.assign({},a)
            b.age = 2
            console.log(a.age) // 1
        ```
    - 扩展运算符`...`
        ```javascript
            let a = {
                age: 1
            }
            let b = { ...a }
            b.age = 2
            console.log(a.age) // 1
        ```
- 深拷贝
    - JSON.parse(JSON.stringify(object)) 
    - 递归

## es6+

> var、let及const区别

- 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部
- var存在提升，我们能在声明之前使用。let、const因为暂时性死区的原因，不能在声明前使用
- var在全局作用域下声明变量会导致变量挂载在window上，其他两者不会
- let声明变量，const声明常量，但是后者声明的变量不能再次赋值

> Proxy

- Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作
- let p = new Proxy(target, handler)
- target代表需要添加代理的对象，handler用来自定义对象中的操作

> map、filter、reduce

- map作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中
    - map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组
    - ['1','2','3'].map(parseInt)
        - 第一轮遍历 parseInt('1', 0) -> 1
        - 第二轮遍历 parseInt('2', 1) -> NaN
        - 第三轮遍历 parseInt('3', 2) -> NaN
- filter的作用也是生成一个新数组，在遍历数组的时候将返回值为true的元素放入新数组，可以利用这个函数删除一些不需要的元素
    - filter 的回调函数接受三个参数，分别是当前索引元素，索引，原数组
- reduce 可以将数组中的元素通过回调函数最终转换为一个值
    - 接受两个参数，分别是回调函数和初始值

> es6模块化如何使用，开发环境如何打包

- 模块化的基本语法
    ```javascript
        // util1.js
        export default {
            a: 100
        }
        
        // util2.js
        export function fn1(){
            alert('fn1)
        }
        export function fn2(){
            alert('fn2)
        }

        // index.js
        import util1 from './util1.js'
        import { fn1, fn2 } from './util2.js'
        console.log(util1)
        fn1()
        fn2()
    ```
- 开发环境配置
    - babel
    - webpack
    - rollup
    
> 关于js众多模块化标准

- AMD成为标准，require.js（也有CMD）
- 前端打包工具，nodejs模块化可以被使用
- ES6出现，想统一现在所有模块化标准

> class和普通构造函数有何区别

- js普通构造函数
    ```javascript
        function MathHandle(x, y) {
            this.x = x
            this.y = y
        }
        
        MathHandle.prototype.add = function () {
            return this.x + this.y
        }

        var m = new MathHandle(1, 2)
        console.log(m.add())
    ```
- class语法
    ```javascript
        class MathHandle {
            constructor(x, y) {
                this.x = x
                this.y = y
            }
            add() {
                return this.x + this.y
            }
        }

        const m = new MathHandle(1, 2)
        console.log(m.add())

        typeof MathHandle // 'function'
        MathHandle.prototype.constructor === MathHandle // true
        m.__proto__ === MathHandle.prototype // true
    ```
- 继承-js
    ```javascript
        // 动物
        function Animal() {
            this.eat = funtion () {
                console.log('Anima eat')
            }
        }

        // 狗
        function Dog() {
            this.bark = funtion () {
                console.log('Dog bark')
            }
        }

        // 绑定原型，实现继承
        Dog.prototype = new Animal()
        
        var hashiqi = new Dog()
        hashiqi.bark()
        hashiqi.eat()
    ```
- 继承-class
    ```javascript
        class Animal {
            constructor(name) {
                this.name = name
            }
            eat() {
                console.log(this.name + ' eat')
            }
        }
        
        class Dog extends Animal {
            constructor(name) {
                super(name) // 注意  继承的constructor
                this.name = name
            }
            say() {
                console.log(this.name + ' say')
            }
        }

        const dog = new Dog('哈士奇')
        dog.say()
        dog.eat()
    ```
- 总结
    - class在语法上更加贴合面向对象的写法
    - class实现继承更加易读、易理解
    - 更易于写java等后端语言的使用
    - 本质还是语法糖，使用prototype

> promise的基本使用

- Callback Hell
    ```javascript
        function loadImg(src, callback, fail) {
            var img = document.createElement('img')
            img.onload = function () {
                callback(img)
            }
            img.onerror = function () {
                fail()
            }
            img.src = src
        }
        var src = 'https://www.imooc.com/static/img/index/logo.png'
        loadImg(src, function(img){
            console.log(img.width)
        }, function() {
            console.log('failed')
        })
    ```
- Promise语法
    ```javascript
        function loadImg(src) {
            const promise = new Promise(function(resolve, reject) {
                var img = document.createElement('img')
                img.onload = function () {
                    resolve(img)
                }
                img.onerror = function () {
                    reject()
                }
                img.src = src
            })
            return promise
        }

        var src = 'https://www.imooc.com/static/img/index/logo.png'
        var result = loadImg(src)

        result.then(function(img) {
            console.log(img.width)
        }, function() {
            console.log('failed')
        })
    ```
- 总结
    - new Promise 实例，而且要return
    - new Promise 时要传入函数，函数有resolve，reject两个参数
    - 成功时执行resolve() 失败时执行reject()
    - then监听结果

> 总结一下es6其他常用功能

- let/const
    ```javascript
        let i = 20;
        i = 200;
        const j = 20;
        // j = 200  报错  常量不能再赋值
    ```
- 多行字符串/模板变量
    ```javascript
        let name = 'zhangsan', age = 20;
        const html = `
                <div>
                    <p>${name}</p>
                    <p>${age}</p>
                </div>
            `;
    ```
- 解构赋值
    ```javascript
        const obj = {a: 100, b: 200}
        const {a, b} = obj
        const arr = ['xxx', 'yyy', 'zzz']
        const [x, y, z] = arr
    ```
- 块级作用域
    ```javascript
        const obj = {a: 100, b: 200}
        for (let item in obj){
            console.log(item)
        }
        // console.log(item) 访问不到
    ```
- 函数默认参数
    ```javascript
        function fn(a, b=0){

        }
    ```
- 箭头函数
    ```javascript
        const arr = [1, 2, 3]
        arr.map(itme => item + 1)
        arr.map((item, index) => {
            console.log(item)
            return item + 1
        })
    ```
    ```javascript
        function fn() {
            console.log('real', this) // real {a: 100}

            var arr = [1, 2, 3]
            arr.map(function (item) {
                console.log(this) // window
            })

            arr.map(item => {
                console.log(this) // {a: 100}
            })
        }
        fn.call({a: 100})
    ```

## 异步

> 什么是单线程，和异步的关系

- 单线程 - 只有一个线程，只能做一件事
    ```javascript
        // 循环运行期间，JS 执行和 DOM 渲染暂时卡顿
        var i, sum = 0;
        for(i = 0; i< 1000000000; i++){
            sum += i;
        }
        console.log(sum)

        // alert 不处理，JS 执行和 DOM 渲染暂时卡顿
        console.log(1)
        alert('hello')
        console.log(2)
    ```
- 原因 - 避免DOM渲染的冲突
    - 浏览器需要渲染DOM
    - js可以修改DOM结构
    - js执行的时候，浏览器DOM渲染会暂停
    - 两段js也不能同时执行（都修改DOM就冲突了）
    - webworker支持多线程，但是不能访问DOM
- 解决方案 - 异步
    ```javascript
        console.log(100)
        setTimeout(function () {
            console.log(200)  // 反正 1000ms 之后执行
        }, 1000)              // 先不管它，先让其他js代码运行  
        console.log(300)
        console.log(400)
    ```
    ```javascript
        console.log(100) 
        $.ajax({
            url: 'xxx',
            success: function (result) { // ajax 加载完才执行
                console.log(result)      // 先不管它，先让其他js代码运行 
            }
        })
        console.log(300)
        console.log(400)
    ```

> 什么是event-loop

- 文字解释
    - 事件轮询，js实现异步的具体解决方案
    - 同步代码，直接执行
    - 异步函数先放在异步队列中
    - 待同步函数执行完毕，轮询执行异步队列的函数
- 实例分析
    ```javascript
        setTimeout(function () {
            console.log(100)
        })
        console.log(200)
        /*
        // 主进程                    // 异步队列
        console.log(200)            function () {
                                        console.log(100)
                                    }
        */
    ```
    ```javascript
        setTimeout(function () {
            console.log(1)
        }, 100)
        setTimeout(function () {
            console.log(2)
        })
        console.log(3)

        /*
        // 主进程                      // 异步队列

        console.log(3)                // 立即被放入
                                        function(){
                                            console.log(2)
                                        }
                                        
                                        // 100ms 之后被放入
                                        function(){
                                            console.log(1)
                                        }
        */
    ```
    ```javascript
        $.ajax({
            url: 'xxx',
            success: function () {
                console.log('a')
            }
        })
        setTimeout(function () {
            console.log('b')
        }, 100)
        setTimeout(function () {
            console.log('c')
        })
        console.log('d')

        /*
        // 主进程                      // 异步队列

        console.log('d')              // 立即被放入
                                        function(){
                                            console.log('c')
                                        }
                                        
                                        // 100ms 之后被放入
                                        function(){
                                            console.log('b')
                                        }
                                        // ajax 加载成功后执行
                                        console.log('a')

                                        不知道ajax加载和100ms快，所以不确定ajax先执行还是100ms快
        */
    ```

> jquery的Deferred

- jquery 1.5之后ajax的改变
- 使用jquery Deferred
    ```javascript
        function waitHandle() {
            var dtd = $.Deferred()
            var wait = function (dtd) {
                var task = function () {
                    console.log('执行完成')
                    // 成功
                    dtd.resolve()
                    // 失败
                    //dtd.reject()
                }
                setTimeout(task, 2000)
                return dtd.promise()  // 注意，这里返回的是promise而不是直接返回 deferred对象
            }
            return wait(dtd)
        }

        var w = waitHandle()  // w接收的就是一个promise对象
        $.when(w)
            .then(function () {
                console.log('ok 1')
            },function () {
                console.log('err 1')
            })
            .then(function () {
                console.log('ok 2')
            },function () {
                console.log('err 2')
            })
        // w.reject() // 执行这句话会直接报错
    ```
- 开放封闭的原则
    - 对扩展开放，对开发封闭

> promise 的基本使用和原理

- 基础语法
    ```javascript
        function loadImg(src) {
            const promise = new Promise(function(resolve, reject) {
                var img = document.createElement('img')
                img.onload = function () {
                    resolve(img)
                }
                img.onerror = function () {
                    reject('图片加载失败')
                }
                img.src = src
            })
            return promise
        }

        var src = 'https://www.imooc.com/static/img/index/logo.png'
        var result = loadImg(src)

        result.then(function(img) {
            console.log(img.width)
            return img
        }, function() {
            console.log('failed')
        }).then(function(img) {
            console.log(img.height)
            return img
        }, function() {
            console.log('failed')
        })
    ```
- 异常捕获（error和reject都要考虑）
    ```javascript
        // 规定：then 只接受一个参数，最后统一用 catch 捕获异常
        result.then(function(img) {
            console.log(img.width)
            return img
        }).then(function(img) {
            console.log(img.height)
        }).catch(function (ex) {
            // 最后统一 catch
            console.log(ex)
        })
    ```
- 多个串联 - 链式执行
    ```javascript
        var src1 = 'https://www.imooc.com/static/img/index/logo.png'
        var result1 = loadImg(src1)
        var src2 = 'https://img.mukewang.com/5d79998b0001a15618720632.jpg'
        var result2 = loadImg(src2)

        // 链式操作
        result1.then(function (img) {
            console.log('第一个图片加载完成')
            return result2 // 重要！！！
        }).then(function (img) {
            console.log('第二个图片加载完成')
        }).catch(function (ex) {
            // 最后统一 catch
            console.log(ex)
        })
    ```
- promise.all 和 promise.race
    ```javascript
        // promise.all 接收一个 promise 对象的数组
        // 待全部完成之后，统一执行 success
        Promise.all([result1, result2])
            .then(datas => {
                // 接收到的 datas 是一个数组，依次包含了多个 promise返回的内容
                console.log(datas[0])
                console.log(datas[1])
            })
        
        // promise.race 接收一个包含多个 promise 对象的数组
        // 只要有一个完成，就执行 success
        Promise.race([result1, result2])
            .then(data => {
                // data 即最先执行完成的 promise 的返回值
                console.log(data)
            })
    ```
- promise标准
    - 状态变化
        - 三种状态：pending  fulfilled  rejected
        - 初始状态是 pending
        - pending变为fulfilled，或者pending变为rejected
        - 状态变化不可逆
    - then
        - promise实例必须实现then这个方法
        - then()必须可以接受两个函数作为参数
        - then()返回的必须是一个promise实例    

> async/await

- 用法
    - 使用 await ，函数必须用async标识
    - await后面跟的是一个promise实例
    - 需要babel-polyfill

    ```javascript
        import 'babel-polyfill'

        function loadImg(src) {
            const promise = new Promise(function(resolve, reject) {
                var img = document.createElement('img')
                img.onload = function () {
                    resolve(img)
                }
                img.onerror = function () {
                    reject('图片加载失败')
                }
                img.src = src
            })
            return promise
        }
        const src1 = 'https://www.imooc.com/static/img/index/logo.png'
        const src2 = 'https://img.mukewang.com/5d79998b0001a15618720632.jpg'

        const load = async function () {
            const result1 = await loadImg(src1)
            console.log(result1)
            const result2 = await loadImg(src2)
            console.log(result2)
        }
        load()
    ```

> Generator

- 原理比较复杂
- 不是异步的直接替代方式
- 有更好更简洁的解决方案async/await
- koa 从Generator改为async/await
```javascript
    // 除了return语句，还可以用yield返回多次
    // 也可以把异步变为同步
    function* getInitList() {
        // 写法
        const res = yield axios.get('')
        // 处理逻辑 
        ...
    }
```

> 常用定时器函数

- setTimeout、setInterval、requestAnimationFrame 

## 手写代码

- 实现一个深拷贝（简易版）
    ```javascript
        function deepClone(obj) {
            // 判断是否是对象类型
            function isObject(o) {
                // 1.typeof o === 'object' || typeof o === 'function' 为true
                // 2.但是typeof判断null也是对象 所以不等于 typeof o !== null
                return (typeof o === 'object' || typeof o === 'function') && typeof o !== null
            }

            // 不是对象类型
            if (!isObject(obj)) {
                throw new Error('非对象')
            }

            // 是对象类型
            let isArray = Array.isArray(obj)
            let newObj = isArray ? [...obj] : {...obj} // 判断是数组还是对象
            
            // Reflect.ownKeys(newObj) 用于返回对象所有属性
            Reflect.ownKeys(newObj).forEach(key => {
                // 1.判断值是否是对象类型
                // 2.不是的话直接赋值
                // 3.是的话调用deepClone函数在执行一遍,直到不是对象类型
                newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
            })

            // 最后返回对象
            return newObj
        }
    ```
- 通过Proxy来实现一个数据响应式
    ```javascript
        let onWatch = (obj, setBind, getLogger) => {
            let handler = {
                get(target, property, receiver) {
                    getLogger(target, property)
                    // 查找并返回target对象的property属性
                    return Reflect.get(target, property, receiver)
                },
                set(target, property, value, receiver) {
                    setBind(value, property)
                    // 设置target对象的property属性为value
                    return Reflect.set(target, property, value)
                }
            }
            return new Proxy(obj, handler)
        }
        let obj = { a: 1 }
        let p = onWatch(
            obj, 
            (v, property) => {
                console.log(`监听到属性${property}改变为${v}`)
            },
            (target, property) => {
                console.log(`'${property}' = ${target[property]}`)
            }
        )
        p.a = 2 // 监听到属性a改变
        p.a // 'a' = 2
    ```
- 手写call函数
    ```javascript
        /*
            首先 context 为可选参数，如果不传的话默认上下文为 window
            接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数
            因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来
            然后调用函数并将对象上的函数删除
        */
        Function.prototype.myCall = function(context) {
            if(typeof this !== 'function') {
                throw new TypeError('Error')
            }
            context = context || window
            context.fn = this
            const args = [...arguments].slice(1)
            const result = context.fn(...args)
            delete context.fn
            return result
        }
    ```
- 手写apply函数
    ```javascript
        Function.prototype.myApple = function(context) {
            if(typeof this !== 'function') {
                throw new TypeError('Error')
            }
            context = context || window
            context.fn = this
            let result
            
            if(arguments[1]) {
                result = context.fn(...arguments[1])
            } else {
                result = context.fn()
            }

            delete context.fn
            return result
        }
    ```
- 手写bind函数
    ```javascript
        /*
            bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式
            对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：
                因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments)
            最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this
        */
        Function.prototype.myBind = function(context) {
            if(typeof this !== 'function') {
                throw new TypeError('Error')
            }
            const _this = this
            const args = [...arguments].slice(1)
            // 返回一个函数
            return function F() {
                // 因为返回了一个函数，我们可以 new F(),所以需求判断
                if(this instanceof F) {
                    return new _this(...args, ...arguments)
                }
                return _this.apply(context, args.concat(...arguments))
            }
        }
    ```
- new的原理
    ```javascript
        /*
          在调用 new 的过程中会发生以上四件事情:  
            1、新生成了一个对象
            2、链接到原型
            3、绑定 this
            4、返回新对象
        */
        /*
            创建一个空对象
            获取构造函数
            设置空对象的原型
            绑定this并执行构造函数
            确保返回值为对象
        */
        function create() {
            let obj = {}
            let Con = [].shift.call(arguments)
            obj.__proto__ = Con.prototype
            let result = Con.apply(obj, arguments)
            return result instanceof Object ? result : obj
        }
    ```
- instanceof的原理
    ```javascript
        /*
            instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype
        */
        /*
            首先获取类型的原型
            然后获得对象的原型
            然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null 
        */
        function myInstanceof(left, right) {
            let prototype = right.prototype
            left = left.__proto__
            while(true) {
                if(left === null || left === undefined) {
                    return false
                }
                if(prototype === left) {
                    return true
                }
                left = left.__proto__
            }
        }
    ```
- 节流
    ```javascript
        // func是用户传入需要防抖的函数
        // wait是等待时间
        const throttle = (func, wait = 50) => {
        // 上一次执行该函数的时间
        let lastTime = 0
        return function(...args) {
            // 当前时间
            let now = +new Date()
            // 将当前时间和上一次执行函数时间对比
            // 如果差值大于设置的等待时间就执行函数
            if (now - lastTime > wait) {
            lastTime = now
            func.apply(this, args)
            }
        }
        }

        setInterval(
            throttle(() => {
                console.log(1)
            }, 500),
            1
        )
    ```
- 防抖
    ```javascript
        // func是用户传入需要防抖的函数
        // wait是等待时间
        const debounce = (func, wait = 50) => {
        // 缓存一个定时器id
        let timer = 0
        // 这里返回的函数是每次用户实际调用的防抖函数
        // 如果已经设定过定时器了就清空上一次的定时器
        // 开始一个新的定时器，延迟执行用户传入的方法
        return function(...args) {
                if (timer) clearTimeout(timer)
                timer = setTimeout(() => {
                    func.apply(this, args)
                }, wait)
            }
        }
    ```

## 虚拟DOM (virtual dom)

> vdom是什么？为何会存在vdom

- 什么是vdom
    - virtual dom，虚拟DOM
    - 用js模拟DOM结构
    - DOM变化的对比，放在js层来做（图灵完备语言）
    - 提高重绘性能
- 为何会存在vdom
    - DOM操作是"昂贵"的，js运行效率高
    - 尽量减少DOM操作，而不是清空重新渲染
    - 将DOM对比操作放在js层，提高效率

> vdom的如何应用，核心api是什么

- 介绍snabbdom
    - 一个虚拟DOM库，专注于简单性，模块化，强大的功能和性能。
    ```html
        <div id="container"><div>
        <button id="btn-change">change</button>

        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/h.js"></script>
        
        <script type="text/javascript">
            var snabbdom = window.snabbdom

            // 定义 pathch
            var pathch = snabbdom.init([
                snabbdom_class,
                snabbdom_props,
                snabbdom_style,
                snabbdom_eventlisteners
            ])

            // 定义 h
            var h = snabbdom.h

            var container = document.getElementById('container')

            // 生成 vnode
            var vnode = h('ul#list', {}, [
                h('li.item', {}, 'Item 1'),
                h('li.item', {}, 'Item 2')
            ])
            pathch(container, vnode)

            document.getElementById('btn-change').addEventListener('click',function () {
                // 生成 newVnode
                var newVnode = h('ul#list', {}, [
                    h('li.item', {}, 'Item 1'),
                    h('li.item', {}, 'Item B'),
                    h('li.item', {}, 'Item 3'),
                ])
                pathch(vnode, newVnode)
            })

        </script>
    ```
- 核心API
    - h函数
        - `h('<标签名>', {...属性...}, [...子元素...])`
        - `h('<标签名>', {...属性...}, '...')`
    - patch函数
        - `pathch(container, vnode)`
        - `pathch(vnode, newVnode)`

> 介绍一下diff算法

- 什么是diff算法
    - Linux 的 diff命令
    - git diff命令
- vdom为何用diff算法
    - DOM操作是"昂贵"的，因此尽量减少DOM操作
    - 找出本次DOM必须更新的节点来更新，其他的不更新
    - 这个"找出"的过程，就需要diff算法
- diff算法的实现流程
    - `pathch(container, vnode)`
        ```
            {
                tag: 'ul',
                attrs: {
                    id: 'list'
                },
                children: [
                    {
                        tag: 'li',
                        attrs: {
                            className: 'item'
                        },
                        children: ['Item 1']
                    }
                ]
            }
                    
            <ul id="list"> 
                <li class="item">Item 1</li>
            </ul>
        ```
        ```javascript
            // 实现
            function createElement(vnode){
                var tag = vnode.tag 
                var attrs = vnode.attrs || {}
                var children = vnode.children || []

                if(!tag){
                    return null
                }

                // 创建真实的 DOM 元素
                var elem = document.createElement(tag)
                // 属性
                var attrName
                for(attrName in attrs){
                    if(attrs.hasOwnProperty(attrName)){
                        // 给 elem 添加属性
                        elem.setAttribute(attrName, attrs[attrName]) 
                    }
                }
                // 子元素
                children.forEach(function (childVnode) {
                    // 给 elem 添加子元素
                    elem.appendChild(createElement(childVnode)) // 递归 
                })
                
                // 返回真实的 DOM 元素
                return elem
            }
        ```
    - `pathch(vnode, newVnode)`
        ```
            {
                tag: 'ul',
                attrs: { id: 'list' },
                children: [
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 1']
                    },
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 2']
                    }
                ]
            } 

            {
                tag: 'ul',
                attrs: { id: 'list' },
                children: [
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 1']
                    },
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 222']
                    },
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 3']
                    }
                ]
            } 
        ```
        ```javascript
            // 实现
            function updateChildren(vnode, newVnode) {
                var children = vnode.children || []
                var newChildren = newVnode.children || []

                children.forEach(function (childVnode, index) {
                    var newChildVnode = newChildren[index]
                    if(childVnode.tag === newChildVnode.tag){
                        // 深层次对比，递归
                        updateChildren(childVnode,newChildVnode)
                    } else {
                        // 替换
                        replaceNode(childVnode,newChildVnode)
                    }
                })  
            }

            function replaceNode(vnode, newVnode){
                var elem = vnode.elem // 真实的 DOM 节点
                var newElem = createElement(newVnode)

                // 替换
            }
        ```
    - 不仅仅是以上内容
        - 节点新增和删除
        - 节点重新排序
        - 节点属性、样式、事件绑定
        - 如何极致压榨性能
        - ......

## vue

> 说一下使用jquery和vue框架的区别

- 数据和视图的分离，解耦(开放封闭原则)
- 以数据驱动视图，只关心数据变化，DOM操作被封装

> 生命周期钩子函数

- 在 beforeCreate 钩子函数调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。
- 然后会执行 created 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。
- 接下来会先执行 beforeMount 钩子函数，开始创建 VDOM，最后执行 mounted 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。
- 接下来是数据更新时会调用的钩子函数 beforeUpdate 和 updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。
- 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。
- 最后就是销毁组件的钩子函数 beforeDestroy 和 destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数。

> 组件通信

- 父子组件通信
    - 父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件
    - 如果你使用 Vue 2.3 及以上版本的话还可以使用 $listeners 和 .sync 这两个属性。
    - $listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners 来自定义监听器。
        ```html
            <!--父组件中-->
            <input :value.sync="value" />
            <!--以上写法等同于-->
            <input :value="value" @update:value="v => value = v"></comp>
            <!--子组件中-->
            <script>
                this.$emit('update:value', 1)
            </script>
        ```
- 兄弟组件通信
    - 对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信。
- 跨多层级组件通信
    - 对于这种情况可以使用 Vue 2.2 新增的 API provide / inject
        ```javascript
            // 父组件 A
            export default {
                provide: {
                    data: 1
                }
            }
            // 子组件 B
            export default {
                inject: ['data'],
                mounted() {
                    // 无论跨几层都能获得父组件的 data 属性
                    console.log(this.data) // => 1
                }
            }
        ```
- 任意组件
    - 这种方式可以通过 Vuex 或者 Event Bus 解决

> extend 能做什么

- 作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。
    ```javascript
        // 创建组件构造器
        let Component = Vue.extend({
            template: '<div>test</div>'
        })
        // 挂载到 #app 上
        new Component().$mount('#app')
        // 除了上面的方式，还可以用来扩展已有的组件
        let SuperComponent = Vue.extend(Component)
        new SuperComponent({
            created() {
                console.log(1)
            }
        })
        new SuperComponent().$mount('#app') 
    ```

> mixin 和 mixins 区别

- mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。
    ```javascript
        Vue.mixin({
            beforeCreate() {
                // ...逻辑
                // 这种方式会影响到每个组件的 beforeCreate 钩子函数
            }
        })
    ```
- mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等

> computed 和 watch 区别

- computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。
- watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。
- 所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。

> keep-alive 组件有什么作用

- 如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。
- 对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。
- 用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。

>  Vue3.0 要使用 Proxy 替换原本的 API 原因

- Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好
- 原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变.
- 唯一缺陷可能就是浏览器的兼容性不好了

> NextTick

- nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。

> vue的三要素

- 响应式：vue如何监听到data的每个属性变化？
- 模板引擎：vue的模板如何被解析，指令如何处理？
- 渲染：vue的模板如何被渲染成html？以及渲染过程

> vue中如何实现响应式

- 什么是响应式
    - 修改data属性之后，vue立即监听到
    - data属性被代理到vm上
- Object.defineProperty
    ```javascript
        var obj = {}
        var _name = 'zhangsan'
        Object.defineProperty(obj, 'name', {
            get: function () {
                console.log('get', _name) // 监听
                return _name
            },
            set: function (newVal) {
                console.log('set', newVal) // 监听
                _name = newVal
            }
        })
    ```

> vue如何解析模板

- 模板是什么
    - 本质：字符串
    - 有逻辑，如v-if，v-for等
    - 与html格式很像，但有很大区别
    - 最终还要转换为html来显示
    - 模板最终必须转换成js代码，因为：
    - 有逻辑(v-if v-for)，必须用js才能实现(图灵完备)
    - 转换为html渲染页面，必须用js才能实现
    - 因此，模板最终要转换成一个js函数(render函数)
- render函数
    - with的用法
        ```javascript
            var obj = {
                name: 'zhangsan',
                age: 20,
                getAddress: function () {
                    console.log('beijing')
                }
            }

            function fn() {
                with(obj) {
                    console.log(name)
                    console.log(age)
                    getAddress()
                }
            }
            fn()
        ```
    - 模板中所有信息都包含在了render函数中
    - this即vm
    - price 即 this.price 即 vm.price 即 data 中的price
    - _c 即 this._c 即 vm._c
    ```html
        <div id="app">
            <p>{{ price }}</p>
        </div>
        <script>
            var vm = new Vue({
                el: 'app',
                data: {
                    price: 100
                }
            })

            // 以下是手写的 render 函数
            function render() {
                with(this) { // this 就是vm
                    return _c(
                        'div',
                        {
                            attrs: { 'id': 'app' }
                        },
                        [
                            _c('p', [ _v(_s(price)) ])
                        ]
                    )
                }
            }
            function render1() {
                return vm._c(
                    'div',
                    {
                        attrs: { 'id': 'app' }
                    },
                    [
                        vm._c('p', [ vm._v(vm._s(vm.price)) ])
                    ]
                )
            }
            // vm.price   100 就是值
            // vm._s   JSON.stringify  转换成字符串
            // vm._v   文本节点
            // vm._c  函数
        </script>
    ```
    ```html
        <div id="app">
            <div>
                <input v-model="title">
                <button v-on:click="add"></button>
            </div>
            <div>
                <ul>
                    <li v-for="item in list">{{item}}</li>
                </ul>
            </div>
        </div>
        <script type="text/javascript">
            // data 独立
            var data = {
                title: '',
                list: []
            }
            // 初始化 Vue 实例
            var vm = new Vue({
                el: '#app',
                data: data,
                methods: {
                    add: function () {
                        this.list.push(this.title)
                        this.title = ''
                    }
                }
            })
            // render 函数
            with(this) {
                return _c('div', {
                    attrs: {
                        "id": "app"
                    }
                }, [_c('div', [_c('input', {
                    directives: [{
                        name: "model",
                        rawName: "v-model",
                        value: (title),
                        expression: "title"
                    }],
                    domProps: {
                        "value": (title)
                    },
                    on: {
                        "input": function ($event) {
                            if ($event.target.composing) return;
                            title = $event.target.value
                        }
                    }
                }), 
                _v(" "), 
                _c('button', {
                    on: {
                        "click": add
                    }
                })]), 
                _v(" "), 
                _c(
                    'div', 
                    [
                        _c('ul', _l((list), function (item) {
                            return _c('li', [_v(_s(item))])
                        }), 0)
                    ]
                )])
            }
        </script>
    ```
    - v-model怎么实现的
        ```javascript
            _c('input', {
                directives: [{
                    name: "model",
                    rawName: "v-model",
                    value: (title),
                    expression: "title"
                }],
                domProps: {
                    "value": (title)
                },
                on: {
                    "input": function ($event) {
                        if ($event.target.composing) return;
                        title = $event.target.value
                    }
                }
            })
        ```
    - v-for怎么实现的
        ```javascript
            _c('ul',
                _l((list), function (item) {
                    return _c('li', [_v(_s(item))])
                })
            , 0)
        ```
- render函数与vdom
    - snabbdom的 h函数 与vue的 _c函数 基本是相似的
    - render函数执行之后，返回的是vnode
        ```javascript
            vm.update(vnode) {
                const prevVnode = vm._vnode
                vm._vnode = vnode
                if(!prevVnode) {
                    vm.$el = vm.__patch__(vm.$el, vnode)
                } else {
                    vm.$el = vm.__patch__(prevVnode, vnode)
                }
            }
            function updateComponent() {
                // vm._render 即 上面的 render 函数 ，返回 vnode
                vm._update(vm._render())
            }
        ```
        - updateComponent 中实现了 vdom 的patch
        - 页面首次渲染执行 updateComponent
        - data 中每次修改属性，执行 updateComponent

> vue的整个实现流程

- 第一步：解析模板成render函数
    - with的用法
    - 模板中的所有信息都被render函数包含
    - 模板中用到的data中的属性，都变成了js变量
    - 模板中的v-model v-for v-on都变成了js逻辑
    - render 函数返回vnode
- 第二步：响应式开始监听
    - Object.defineProperty
    - 将data的属性代理到vm上
- 第三步：首次渲染，显示页面，且绑定依赖
    - 初次渲染，执行 updateComponent，执行vm._render()
    - 执行render函数，会访问到vm.list和vm.title
    - 会被响应式的get方法监听到
        - 为何要监听get，直接监听set不行吗？
            - data中有很多属性，有些被用到，有些可能不被用到
            - 被用到的会走到get，不被用到的不会走到get
            - 未走到get中的属性，set的时候我们也无需关心
            - 避免不必要的重复渲染
    - 执行updateComponent，会走到vdom的patch方法
    - patch将vnode渲染成DOM，初次渲染完成
- 第四步：data属性变化，触发rerender
    - 修改属性，被响应式的set监听到
    - set中执行updateComponent
    - updateComponent重新执行vm._render()
    - 生成的vnode和prevVnode，通过patch进行对比
    - 渲染到html

## react 

> react 的生命周期

- 生命周期函数指在某一个时刻组件会自动调用执行的函数
- 组件初始化 initialization
    - 设置 props和state
- 组件的挂载 Mounting
    - componentWillMount
        - 在组件即将被挂载到页面的时刻自动执行
    - render
    - componentDidMount
        - 组件被挂载到页面之后，自动被执行
- 组件的更新 Updation
    - state更新时
        - shouldComponentUpdate
            - 组件被更新之前，它会自动被执行
            - retuen true会往下执行
            - return false不会往下执行
        - componentWillUpdate
            - 组件被更新之前，它会自动执行，但是它在shouldComponentUpdate之后
            - 如果shouldComponentUpdate返回true，它才执行
            - 如果返回false，这个函数就不会被执行了
        - render
        - componentDidUpdate
            - 组件更新完成之后，它会被执行
    - props更新时
        - componentWillReceiveProps
            - 一个组件要从父组件接收参数
            - 如果这个组件第一次存在于父组件中，不会执行
            - 如果这个组件之前已经存在于父组件中，才会执行
        - shouldComponentUpdate
            - 组件被更新之前，它会自动被执行
            - retuen true会往下执行
            - return false不会往下执行
        - componentWillUpdate
            - 组件被更新之前，它会自动执行，但是它在shouldComponentUpdate之后
            - 如果shouldComponentUpdate返回true，它才执行
            - 如果返回false，这个函数就不会被执行了
        - render
        - componentDidUpdate
            - 组件更新完成之后，它会被执行
- 组件的卸载 Unmounting
    - componentWillUnmount
        - 当这个组件即将从页面中剔除的时候，会被执行

> setState

- setState是异步的
- 可以通过第二个参数通过回调函数处理后面的逻辑

> 通信

- 父子组件通信
    - 父组件通过 props 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件
- 兄弟组件通信
    - 对于这种情况可以通过共同的父组件来管理状态和事件函数。
    - 比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。
- 跨多层级组件通信
    - 如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。
        ```JSX
            // 创建 Context，可以在开始就传入值
            const StateContext = React.createContext()
            class Parent extends React.Component {
                render () {
                    return (
                        // value 就是传入 Context 中的值
                        <StateContext.Provider value='yck'>
                            <Child />
                        </StateContext.Provider>
                    )
                }
            }
            class Child extends React.Component {
                render () {
                    return (
                        <ThemeContext.Consumer>
                            // 取出值
                            {context => (
                                name is { context }
                            )}
                        </ThemeContext.Consumer>
                    );
                }
            }
        ```
- 任意组件
    - 这种方式可以通过 Redux 或者 Event Bus 解决

> HOC 是什么？

- 高阶组件（HOC）
- 作用就是为了更好的复用代码

> Hooks

> react 几个性能优化

- 避免重复渲染,判断是否让render函数执行
    ```javascript
        // 性能优化
        shouldComponentUpdate(nextProps, nextState) {
            // 对比数据是否相同，从而是否让render函数执行
            if (nextProps.content != this.props.content) {
                return true;
            } else {
                return false;
            }
        }

        // react 为了防止每个页面都写shouldComponentUpdate
        // 底层实现了api Component改成 PureComponent
        // 如果用 PureComponent 的话 要用 immutable管理数据。不然会遇到坑
        import React, { Component } from 'react';
        import React, { PureComponent } from 'react';
    ```
- 做循环时key的取值，尽量不要用index下标
    - 一般用item做为key值
    - 设置key值是为了虚拟dom做对比的时候，快速定位
- ajax请求放在componentDidMount里
- 当普通组件只有render函数时，用无状态组件定义
    - 无状态组件性能比普通组件好，因为普通组件要执行生命周期函数

> 单向数据流

- react 父组件向子组件传值是只读属性
- 一般修改父组件的数据是父组件向子组件传递父组件的一个方法让子组件调用，从而修改数据

> 说一下对组件化的理解

- 组件的封装
    - 视图
    - 数据
    - 变化逻辑(数据驱动视图变化)
- 组件的复用
    - props传递
    - 复用

> JSX本质是什么

- JSX语法
    - html形式
    - 引入js变量和表达式
    - if...else...
    - 循环
    - style和className
    - 事件
- JSX解析成js
    - React.createElement 参数说明
        ```javascript
            // React.createElement 参数说明
            React.createElement('div', {id: 'div1'}, child1, child2, child3)
            React.createElement('div', {id: 'div1'}, [...])
        ```
    - 解析
        ```jsx
            /* JSX 代码 */
            var profile = <div>
                            <img src="avatar.png" className="profile"/>
                            <h3> {[user.firstName, user.lastName].join(' ')}</h3>
                          </div>;

            // 解析结果
            var profile = React.createElement("div", null,
                React.createElement("img", { src:"avatar.png" className: "profile"}),
                React.createElement("h3", null, [user.firstName, user.lastName].join(' '))
            )
        ```
    - JSX其实是语法糖
    - 开发环境会将JSX编译成js代码
    - JSX的写法大大降低了学习成本和编码工作量
    - 同时，JSX也会增加debug成本
- 独立的标准
    - JSX是React引入的，但不是React独有的
    - React已经将它作为一个独立标准开放，其他项目也可用
    - React.createElement是可以自定义修改的
    - 说明：本身功能已经具备；和其他标准兼容和扩展性没问题

> JSX和vdom的关系

- 分析：为何需要vdom
    - vdom是React初次推广开来的，结合JSX
    - JSX就是模板，最终要渲染成html
    - 初次渲染+修改state后的re-render
    - 正好符合vdom的应用场景
- React.createElement和h
    ```jsx
            /* JSX 代码 */
            var profile = <div>
                            <img src="avatar.png" className="profile"/>
                            <h3> {[user.firstName, user.lastName].join(' ')}</h3>
                          </div>;

            // 解析结果
            var profile = React.createElement("div", null,
                React.createElement("img", { src:"avatar.png" className: "profile"}),
                React.createElement("h3", null, [user.firstName, user.lastName].join(' '))
            )


            // h函数
            var vnode = h("div", null,
                h("img", { src:"avatar.png" className: "profile"}),
               h("h3", null, [user.firstName, user.lastName].join(' '))
            )
        ```
- 何时patch？
    - 初次渲染 - `ReactDOM.render(<App/>, container)`
    - 会触发patch(container, vnode)
    - re-render - `setState`
    - 会触发patch(vnode, newVnode)
- 自定义组件的解析
    - 自定义组件要用render返回
    - new 自定义组件

> 说一下setState的过程

- setState的异步
    - setState为何需要异步
        - 可能会一次执行多次setState
        - 你无法规定、限制用户如何使用setState
        - 没必要每次setState都重新渲染，考虑性能
        - 即便是每次重新渲染，用户也看不到中间的效果
        - 只看到结果即可
- vue修改属性也是异步
    - set中执行updateComponent  是异步的
- setState的过程
    - 每个组件实例，都有renderComponent方法
    - 执行renderComponent会重新执行实例的render
    - render函数返回newVnode，然后拿到preVnode
    - 执行patch(proVnode, newVnode)

> 阐述自己对react和vue的认识

- 两者的本质区别
    - vue - 本质是MVVM框架，由MVC发展而来
    - React - 本质是前端组件化框架，由后端组件化发展而来
    - 但这并不妨碍他们两者都能实现相同的功能
- 模板的区别
    - vue - 使用模板(最初由angular提出)
    - React - 使用JSX
    - 模板语法上，我更加倾向于JSX
        ```html
            // vue
            <div>
                <p v-if="ok">YES</p>
                <p v-else>NO</p>
            </div>

            // react
            <div>
                { ok ? <p>YES</p> : <p>NO</p> }
            </div>
        ```
    - 模板分离上，我更加倾向于vue
        - react 模板和js混在一起，未分离
- 组件化的区别
    - React本身就是组件化，没有组件化就不是React
    - vue也支持组件化，不过是在MVVM上的扩展
- 两者共同点
    - 都支持组件化
    - 都是数据驱动视图
- 如何选择
    - 国内使用，首推vue。文档更易读、易学、社区够大
    - 如果团队水平较高，推荐使用react。组件化和JSX

## vue和react对比

> 路由

- 监听url的变化
    - Hash 模式
        ```javascript
            /*
                www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 www.test.com。
            */
            window.addEventListener('hashchange', () => {
                // ... 具体逻辑
            })
        ```
    - History 模式
        ```javascript
            /*
                History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。
                通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。
            */
            // 新增历史记录
            history.pushState(stateObject, title, URL)
            // 替换当前历史记录
            history.replaceState(stateObject, title, URL)
            // 当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件
            window.addEventListener('popstate', e => {
                // e.state 就是 pushState(stateObject) 中的 stateObject
                console.log(e.state)
            })
        ```
    - 两种模式对比
        - Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL
        - History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
        - Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候

> 说一下对MVVM的理解

- MVC
    - MVC:主要分为三个部分
        - 视图（view）：用于用户界面
        - 控制器（controller）：用于业务逻辑
        - 模型（model）：用于数据保存
    - View传送指令到Controller，
    - Controller完成业务逻辑后，要求Model改变状态，
    - Model将新的数据发送到View，用户得到反馈 
- MVVM
    - MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。
        - Model层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；
        - View代表UI组件，它负责将数据模型转化成UI展现出来；
        - ViewModel是一个同步View和Model的对象。
    - 在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，Model和ViewModel之间的交互是双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反应到View上。
    - ViewModel通过双向数据绑定把View层和Model层连接了起来，而View和Model之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理。


## webpack

> 性能优化

- 减少Webpack时间
    - 优化Loader
        - 优化Loader文件的搜索范围
            ```javascript
                module: {
                    rules: [
                        {
                            // js 文件才使用 babel
                            test: /\.js$/,
                            loader: 'babel-loader',
                            // 只在 src 文件夹下查找
                            include: [resolve('src')],
                            // 不会去查找的路径
                            exclude: /node_modules/
                        }
                    ]
                }
            ```
        - 将 Babel 编译过的文件缓存起来
            ```javascript
                loader: 'babel-loader?cacheDirectory=true'
            ```
    - HappyPack
        - HappyPack 可以将 Loader 的同步执行转换为并行的
            ```javascript
                plugins: [
                    new HappyPack({
                        id: 'happybabel',
                        loaders: ['babel-loader?cacheDirectory'],
                        // 开启 4 个线程
                        threads: 4
                    })
                ]
            ```
    - DllPlugin
        - DllPlugin 可以将特定的类库提前打包然后引入。
            ```javascript
                plugins: [
                    new webpack.DllPlugin({
                        // name 必须和 output.library 一致
                        name: '[name]-[hash]',
                        // 该属性需要与 DllReferencePlugin 中一致
                        context: __dirname,
                        path: path.join(__dirname, 'dist', '[name]-manifest.json')
                    })
                ]
            ```
    - 代码压缩
        - 在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码
        - 在 Webpack4 中，只需要将 mode 设置为 production 就可以默认开启以上功能。
    - 减少 Webpack 打包后的文件体积
        - 按需加载
        - Tree Shaking 可以实现删除项目中未被引用的代码

> webpack.config.js

```javascript
    module.exports = {
        // 入口文件
        entry: './src/index.js',
        // 出口文件
        output: {
            path: __dirname,
            filename: './build/bundle.js'
        },
        // 加载器
        module: {
            rules: [
                {
                    test: /\.js?$/,
                    exclude: /(node_modules)/,
                    loader: 'babel-loader'
                }
            ]
        }
    }
```

## 小程序

> uni-app

- 注意事项
    - 微信小程序
        - 请求接口只支持https
        - 预览按钮只有在设置appID后才能使用，可以设置在manifest.json文件中
    - uni-app
        - 设置导航栏 只设置app-plus的话  h5会默认app-plus
        - 全局变量可以配置到main.js里挂载到Vue.prototype上
    - H5
        - 下载图片可能会存在跨域问题
    - app
        - 设置分享时，需要在manifest.json设置appId等值。本地调试时，可以随便写 
    - 非 H5 端，不能使用浏览器自带对象，比如 document、window、localstorage、cookie 等，更不能使用 jquery 等依赖这些浏览器对象的框架。因为各家小程序快应用都不支持这些对象。没有这些浏览器自带对象并不影响业务开发，uni 提供的 api 足够完成业务。
    - uni-app 的 tag 同小程序的 tag，和 HTML 的 tag 不一样，比如 div 要改成 view，span 要改成 text、a 要改成 navigator。
- vue语法
- 条件编译

## hybrid

> hybrid是什么，为何用hybrid？

- hybrid文字解释
    - hybrid即"混合"，即前端和客户端的混合开发
    - 需前端开发人员和客户端开发人员配合完成
    - 某些环节也可能涉及到server端
- 存在价值，为何会用hybrid
    - 可以快速迭代更新
    - 体验流畅
    - 减少开发和沟通成本，双端公用一套代码
- webview
    - 是app中的一个组件(app可以有webview，也可以没有)
    - 用于加载h5页面，即一个小型的浏览器内核
- file:// 协议
    - file协议：本地文件，快
    - http(s)协议：网络加载，慢
- hybrid实现流程
    - 不是所有场景都适合使用hybrid
    - 使用NA(原生)：体验要求极致，变化不频繁(如头条的首页)
    - 使用hybrid：体验要求高，变化频繁(如头条的新闻详情页)
    - 使用h5：体验无要求，不常用(如举报、反馈等页面)
    - 具体实现
        - 前端做好静态页面(html js css)，将文件交给客户端
        - 客户端拿到前端静态页面，以文件形式存储在app中
        - 客户端在一个webview中
        - 使用file协议加载静态页面
        
> 介绍一下hybrid更新和上线的流程

- hybrid更新
    - 要替换每个客户端的静态文件
    - 只能客户端来做
    - 客户端去server下载最新的静态文件
    - 我们维护server的静态文件
- 完整流程
    - 分版本，有版本号，如201803211015
    - 将静态文件压缩成zip包，上传到服务端
    - 客户端每次启动，都去服务端检查版本号
    - 如果服务端版本号大于客户端版本号，就去下载最新的zip包
    - 下载完之后解压包，然后将现有文件覆盖

> hybrid和h5的主要区别

- 优点
    - 体验更好，更NA体验基本一致
    - 可快速迭代，无需app审核
- 缺点
    - 开发成本高。联调、测试、查bug都比较麻烦
    - 运维成本高。
- 适用的场景
    - hybrid：产品的稳定功能，体验要求高，迭代频繁
    - h5：单次的运营活动(如xx红包)或不常用功能

> 前端js和客户端如何通讯?

- 新闻详情页适用hybrid，前端如何获取新闻内容?
    - 不能用ajax获取。第一跨域，第二速度慢
    - 客户端获取新闻内容，然后js通讯拿到内容，再渲染
- js和客户端通讯的基本形式
    - js访问客户端能力，传递参数和回调函数
    - 客户端通过回调函数返回内容
- schema协议简介和使用
    - schema协议 - 前端和客户端通讯的约定
    - 使用
        ```javascript
            /* 以下是演示，无法正常运行，微信有严格的权限验证，外部页面不能随意使用 schem */
            var iframe = document.createElement('iframe')
            iframe.style.display = 'none'
            iframe.src = 'weixin://dl/scan' // 扫一扫 //ifram 访问 schema  
            var body = document.body || document.getElementsByTagName('body')[0]
            body.appendChild(iframe)
            setTimeout(function() {
                body.removeChild(iframe) // 销毁 iframe
                iframe = null
            })

            /* 如果要加上参数和 callback，那么就要这么写 */
            window['_weixin_scan_callback'] = function (result) {
                alert(result)
            }
            var iframe = document.createElement('iframe')
            iframe.style.display = 'none'
            iframe.src = 'weixin://dl/scan?k1=va&k2=v2&k3=v3&callback=_weixin_scan_callback'
            var body = document.body || document.getElementsByTagName('body')[0]
            body.appendChild(iframe)
            setTimeout(function() {
                body.removeChild(iframe) // 销毁 iframe
                iframe = null
            })
        ```
- schema使用的封装
    ```javascript
        (function(window, undefined) {

            // 调用 schema 的封装
            function _invoke(action, data, callback) {
                // 拼装 schema 协议
                var schema = 'myapp://utils/' + action

                // 拼接参数
                schema += '?a=a'
                var key 
                for(key in data) {
                    if(data.hasOwnProperty(key)) {
                        schema += '&' + key + data[key]
                    }
                }

                // 处理callback
                var callbackName = ''
                if(typeof callback === 'string') {
                    callbackName = callback
                } else {
                    callbackName = action + Date.now()
                    window[callbackName] = callback
                }
                schema += 'callback=callbackName'

                // 触发
                var iframe = document.createElement('iframe')
                iframe.style.display = 'none'
                iframe.src = schema
                var body = document.body || document.getElementsByTagName('body')[0]
                body.appendChild(iframe)
                setTimeout(function() {
                    body.removeChild(iframe) // 销毁 iframe
                    iframe = null
                })
            }
            
            // 暴露到全局变量
            window.invoke = {
                share: function (data, callback) {
                    _invoke('share', data, callback)
                },
                scan: function (data, callback) {
                    _invoke('scan', data, callback)
                },
                login: function (data, callback) {
                    _invoke('login', data, callback)
                },
            }
        })(window)
    ```
- 内置上线
    - 将以上封装的代码打包，叫做invoke.js，内置到客户端
    - 客户端每次启动webview，都默认执行invoke.js
    - 本地加载，免去网络加载的时间，更快。
    - 本地加载，没有网络请求，黑客看不到schema协议，更安全

## TypeScript

## web存储

> cookie

- 一般由服务器生成，可以设置过期时间
- 数据存储大小 4k
- 每次请求都会携带在 header 中，对于请求性能影响

> localStorage

- 除非被清理，否则一直存在
- 数据存储大小 5M

> sessionStorage

- 页面关闭就清理
- 数据存储大小 5M

## 设计模式 (常用的几个)

> 工厂模式

```javascript
    /*
        假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些负责的代码，
        只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，
        内部逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。
    */
    class Man {
        constructor(name) {
            this.name = name
        }
        alertName() {
            alert(this.name)
        }
    }

    class Factory {
        static create(name) {
            return new Man(name)
        }
    }

    Factory.create('xxx').arertName()
```

> 单例模式

```javascript
    /*
        单例模式的核心就是保证全局只有一个对象可以访问
    */
    class Singleton{
        constructor() {}
    }
    Singleton.getInstance = (function() {
        let instance
        return function() {
            if (!instance) {
            instance = new Singleton()
            }
            return instance
        }
    })()
```

> 适配器模式

```javascript
    /*
        适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，
        通过包装一层的方式实现两个接口的正常协作。
    */
    class Plug {
        getName() {
            return '1类插头'
        }
    }

    class Target {
        constructor() {
            this.plug = new Plug()
        }
        getName() {
            return this.plug.getName + ' 适配器转 2类插头'
        }
    }
    let target = new Target()
    target.getName() // 1类插头 适配器转 2类插头
```

> 装饰模式

```javascript
    /*
        装饰模式不需要改变已有的接口，作用是给对象添加功能。
    */
    function readonly(target, key, descriptor) {
        descriptor.writable = false
        return descriptor
    }

    class Test {
        @readonly
        name = 'xxx'
    }

    let t = new Test()
    t.xxx = '111'  // 不可修改

    // 类似于 Object.defineProperty(name, 'xxx', descriptor)
    // writable=false 属性不可修改
```

> 代理模式

```javascript
    /*
        代理是为了控制对对象的访问，不让外部直接访问到对象。
    */
    <ul id="ul">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
    <script>
        let ul = document.querySelector('#ul')
        ul.addEventListener('click', (event) => {
            console.log(event.target);
        })
    </script>
```

> 发布-订阅模式

```javascript
    /*
        发布-订阅模式也叫做观察者模式。
        通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。
    */
    // 比如我们点击一个按钮触发了点击事件就是使用了该模式
    <ul id="ul"></ul>
    <script>
        let ul = document.querySelector('#ul')
        ul.addEventListener('click', (event) => {
            console.log(event.target);
        })
    </script>
```

> 外观模式

```javascript
    /*
        外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。
    */
    // 实现一个兼容多种浏览器的添加事件方法
    // 将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 addEvent 即可
    function addEvent(elm, evType, fn, useCapture) {
        if (elm.addEventListener) {
            elm.addEventListener(evType, fn, useCapture)
            return true
        } else if (elm.attachEvent) {
            var r = elm.attachEvent("on" + evType, fn)
            return r
        } else {
            elm["on" + evType] = fn
        }
    }
```

## 算法题

## 浏览器相关的一些问题

> 事件机制

- 事件触发三阶段
    - window往事件触发处传播，遇到注册的捕获事件会触发
    - 传播到事件触发处时触发注册的事件
    - 从事件触发处往window传播，遇到注册的冒泡事件会触发
- 注册事件
    - addEventListener 注册事件
        - capture：布尔值，和 useCapture 作用一样
        - once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听
        - passive：布尔值，表示永远不会调用 preventDefault
    - stopPropagation阻止事件冒泡，也能阻止捕获事件
- 事件代理
    - 优点
        - 节省内存
        - 不需要给子节点注销事件

> 输入 URL 到页面渲染的整个流程

- 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
- 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
- 载入解析到的资源文件，渲染页面，完成。

> 跨域

- JSONP
    - JSONP 的原理很简单，就是利用 <script> 标签没有跨域限制的漏洞。
    - 通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。
    - 但是只限于 get 请求
- CORS
    - CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
- document.domain
    - 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式
- postMessage
    - 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

> 浏览器渲染原理

- 浏览器接收到 HTML 文件并转换为 DOM 树
- 将 CSS 文件转换为 CSSOM 树
- 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

> 重绘（Repaint）和回流（Reflow）

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
- 回流是布局或者几何属性需要改变就称为回流。
- 回流必定会发生重绘，重绘不一定会引发回流。

> 减少重绘和回流

- 使用 transform 替代 top
- 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 不要把节点的属性值放在一个循环里当成循环里的变量
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
- CSS 选择符从右往左匹配查找，避免节点层级过多

## 安全防范知识点

> XSS

- XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。
    - 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。
    - 防御
        - 转义字符
        - CSP
            - CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行
- CSRF
    - CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。
    - 防御
        - get请求不对数据进行修改
        - 不让第三方网站访问到用户cookie
        - 阻止第三方网站请求接口
        - 请求时附带验证信息，比如验证码或者Token
- 点击劫持
    - 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
    - 防御
        - X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。
        - JS 防御：原理是把iframe标签清掉
- 中间人攻击
    - 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。
    - 防御
        - HTTPS

## 性能优化

> 图片优化

- 计算图片大小
    - 减少像素点
    - 减少每个像素点能够显示的颜色
- 图片加载优化
    - 不用图片。修饰类图片完全可以用css去代替
    - 移动端图片没必要放原图。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片
    - 小图使用base64格式
    - 将多个图标文件整合到一张图片中（雪碧图）
    - 选择正确的图片格式：
        - 对于能够显示WebP格式的浏览器尽量使用WebP格式。
            - 因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
        - 小图使用PNG，其实对于大部分图标这类图片，完全可以使用SVG代替
        - 照片使用JPEG 

> DNS 预解析

- DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。
    ```html
        <link rel="dns-prefetch" href="//yuchengkai.cn">
    ```

> 节流

- 考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。

> 防抖

- 考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

> 预加载

- 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载
    ```html
        <link rel="preload" href="http://example.com">
    ```
- 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

> 预渲染

- 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染
    ```html
        <link rel="prerender" href="http://example.com"> 
    ```
- 预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。

> 懒执行

- 懒执行就是将某些逻辑延迟到使用时再计算。
- 该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。
- 懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒

> 懒加载

- 懒加载就是将不关键的资源延后加载。

> CDN

- CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。
- 因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。
- 并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

## 网络

> UDP

- 首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。
- 面向无连接
    - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
    - 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
- 不可靠性
    - 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠
    - 在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。
- 高效
    - 保证数据不丢失且有序到达
- 传输方式
    - UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。
- 适合使用的场景
    - 直播
    - 王者荣耀

> TCP

- 建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。
- 三次握手
    - 第一次握手
        - 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。
    - 第二次握手
        - 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。
    - 第三次握手
        - 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。
- 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接？
    - 因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。
- 断开链接四次握手（TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。）
    - 第一次握手
        - 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。
    - 第二次握手
        - B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。
    - 第三次握手
        - B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
    - 第四次握手
        - A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

> HTTP

- HTTP 请求由三部分构成
    - 请求行
    - 首部
    - 实体
- Post 和 Get 的区别？
    - Get 请求能缓存，Post 不能
    - Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
    - URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
    - Post 支持更多的编码类型且不对数据类型限制
- 常见状态码
    - 200 OK，表示从客户端发来的请求在服务器端被正确处理
    - 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
    - 302 found，临时性重定向，表示资源临时被分配了新的 URL
    - 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
    - 403 forbidden，表示对请求资源的访问被服务器拒绝
    - 404 not found，表示在服务器上没有找到请求的资源
    - 500 internal sever error，表示服务器端在执行请求时发生了错误
    - 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
    - 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

> TLS

- HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。
- 在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。
    - 对称加密：
        - 对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。
    - 非对称加密：
        - 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

> HTTP2及HTTP3

- 在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。
- 之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。
- 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。
- 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。
- 在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
- 在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。
- Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 HTTP-over-QUIC
- UIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。

## 了解数据结构

> 时间复杂度和空间复杂度

> 排序

> 二叉树
