<!-- TOC -->

- [前端](#前端)
    - [html](#html)
    - [css](#css)
    - [javascript](#javascript)
    - [es6+](#es6)
    - [异步](#异步)
    - [手写代码](#手写代码)
    - [虚拟DOM (virtual dom)](#虚拟dom-virtual-dom)
    - [vue](#vue)
    - [react](#react)
    - [webpack](#webpack)
    - [小程序](#小程序)
    - [hybrid](#hybrid)
    - [web存储](#web存储)
    - [设计模式 (常用的几个)](#设计模式-常用的几个)
    - [算法题](#算法题)
    - [浏览器相关的一些问题](#浏览器相关的一些问题)
    - [了解数据结构](#了解数据结构)

<!-- /TOC -->

# 前端

## html

> Doctype是什么？

- 用于告知浏览器以何种模式来渲染文档

> html语义化是什么？

- 当页面样式加载失败的时候能够让页面呈现出清晰的结构
- 有利于seo优化，利于被搜索引擎收录
- 便于项目的开发及维护，使html代码更具有可读性，便于其他设备解析

> 行内元素、块级元素？

- 行内元素：a、b、i、span、input等
- 块级元素：div、p、h1~h6、form等

> src和href的区别是什么？

- src：指向外部资源的位置，指向的内容将会嵌入文档中当前标签所在的位置。当浏览器解析到该元素时，会暂停其他资源的下载和处理
- href：指向网络资源的位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。当浏览器解析到该元素时，会并行下载资源并且不会停止对当前文档的处理

> iframe有那些缺点？

- 会阻塞主页面的onload事件
- 即使内容为空，加载也需要时间
- 没有语义

> html5常用新标签

- `<nav>` 表示导航
- `<header>` 表示页眉
- `<footer>` 表示页脚
- `<section>` 表示区块
- `<aside>` 表示侧边栏

## css

> 常用页面布局

- 三栏布局（三栏布局两侧宽度固定不变，中间部分自动填充整个区域）
    - (1) 定位
        ```html
            <!-- 外层一个div盒子包裹三个子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
                <div class="right">3</div>
            </div>
        ```
        ```css
            /* 
                外层盒子相对定位，
                内层左右盒子固定宽度且绝对定位，
                内层中间盒子宽度100%，内边距设置成左右盒子的宽度值，并设置box-sizing: border-box;改变盒模型
            */
            .box{
                width: 100%;
                height: 100%;
                position: relative;
            }
            
            .left {
                width: 200px;
                background-color: antiquewhite;
                position: absolute;
                top: 0;
                left: 0;
            }

            .right {
                width: 200px;
                background-color: antiquewhite;
                position: absolute;
                top: 0;
                right: 0;
            }

            .center {
                width: 100%;
                background-color: burlywood;
                padding: 0 200px;
                box-sizing: border-box;
            }
        ```
    - (2) flex
         ```html
            <!-- 外层一个div盒子包裹三个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
                <div class="right">3</div>
            </div>
        ```
        ```css
            /*
                外层盒子设置display: flex;
                内层盒子左右固定宽度，中间盒子设置flex:1
            */
            .box{
                width: 100%;
                height: 100%;
                display: flex;
            }
            .left {
                width: 200px;
                background-color: antiquewhite;
            }

            .right {
                width: 200px;
                background-color: antiquewhite;
            }

            .center {
                width: 100%;
                flex: 1;
                background-color: burlywood;
            }
        ```
- 两栏布局(左侧固定右侧自适应布局)
    - (1) 定位
        ```html
            <!-- 外层一个div盒子包裹两个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
            </div>
        ```
        ```css
            /* 
                外层盒子相对定位，
                内层左盒子固定宽度且绝对定位，
                内层中间盒子宽度100%，内边距设置成左盒子的宽度值，并设置box-sizing: border-box;改变盒模型
            */
            .box {
                width: 100%;
                height: 100%;
                position: relative;
            }

            .left {
                width: 200px;
                position: absolute;
                left: 0;
                top: 0;
                background-color: antiquewhite;
            }

            .center {
                width: 100%;
                padding-left: 200px;
                box-sizing: border-box;
                background-color: burlywood;
            }
        ```
    - (2) flex
        ```html
            <!-- 外层一个div盒子包裹两个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
            </div>
        ```
        ```css
            /*
               外层盒子设置display: flex;
               内层盒子左固定宽度，中间盒子设置flex:1 
            */
            .box {
                width: 100%;
                height: 100%;
                display: flex;
            }

            .left {
                width: 200px;
                background-color: antiquewhite;
            }

            .center {
                width: 100%;
                flex: 1;
                background-color: burlywood;
            }
        ```
    - (3) 浮动
        ```html
            <!-- 外层一个div盒子包裹两个子盒子 -->
            <div class="box">
                <div class="left">1</div>
                <div class="center">2</div>
            </div>
        ```
        ```css
            /*
               内层盒子左固定宽度并设置左浮动，中间盒子设置左侧外边距为左盒子的宽
            */
            .box {
                width: 100%;
                height: 100%;
            }

            .left {
                width: 200px;
                float:left;
                background-color: antiquewhite;
            }

            .center {
                margin-left:200px;
                background-color: burlywood;
            }
        ```
- 上中下结构布局
    - 定位
        ```html
            <!-- 三个div盒子 -->
            <div class="header">1</div>
            <div class="container">2</div>
            <div class="footer">3</div>
        ```
        ```css
            /*
                初始化html和body样式并设置宽高为100%
                顶部盒子固定定位设置top:0
                底部盒子固定定位设置bottom：0
                中间盒子设置内边距等于顶部和底部盒子的高度值，并设置box-sizing: border-box;改变盒模型。设置最小高度为100%

            */
            html,body{
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
            }
            .header{
                width: 100%;
                height: 20px;
                background-color: #b9ffd8;
                position: fixed;
                top: 0;
                left: 0;
            }
            .container{
                width: 100%;
                min-height: 100%;
                padding: 20px 0;
                box-sizing: border-box;
                background-color: #d7ff7c;
            }
            .footer{
                width: 100%;
                height: 20px;
                position: fixed;
                bottom: 0;
                left: 0;
                background-color: #1d1d1d;
            }
        ```
- css实现垂直居中
    ```css
        .content{
            weith:200px;
            height:200px;
            /* flex
            display:flex;
            justify-content:center;
            align-items:center;
            */

            /* 定位
            position:absolute;
            top:50%;
            left:50%;
            margin-left:-100px;
            margin-top:-100px;
            */
            
            /* css3
            transform:translate(-50%,-50%);
            */
        }
        <div class="content"></div>
    ```

> BFC (块级格式化上下文)

- 从理论上讲父元素包裹的元素不会影响旁边的元素
- 官方定义
    - 它决定了元素如何对其内容进行定位 以及与其他元素的关系和相互作用 当涉及到可视化布局的时候 Block Formatting Context提供了一个环境 HTML元素在这个环境中按照一定规则进行布局
- BFC的目的是 形成一个完全独立的空间 让空间里的子元素不会影响到外面的布局
- 触发BFC (常用规则)
    1. float不为none
    2. position不为relative和static
    3. overflow为auto scroll和hidden
    4. display的值为table-cell和inline-block
- 利用BFC解决问题
    1. 解决浮动元素令父元素高度坍塌的问题
        - 假设页面里有一个父元素和几个子元素，这几个子元素都设为浮动时，父元素高度坍塌，这是因为浮动的子元素脱离了文档流，父元素检测不到它的存在无法被它撑开，这时给父元素添加属性overflow:hidden。也可以添加属性display:table-cell，或者是position:fixed等等,这些属性都是触发了BFC。触发了BFC的容器就是页面上的一个完全隔离开的容器，容器里的子元素绝对不会影响到外面的元素，为了保证这样的规则，不得不让浮动的子元素也参与进来，变相地实现了清除内部浮动的目的
        - 常用的办法
            1. 让父元素也浮动起来，这样父元素和子元素一起脱离文档流，这样父元素就能自适应子元素的高度
                - 缺点：会影响父元素之后的元素排列
            2. 给父元素添加一个固定高度
            3. 在一个浮动的子元素后面增加一个空元素，设置clear:both来清除浮动
                - 缺点：增加无意义标签，不利于维护
            4. 为浮动的最后一个子元素设置伪元素::after{clear:both}
    2. 解决自适应布局的问题
        - 两栏布局 (左侧固定，右侧自适应)
            - 左边设置float:left;width:200px。右边设置margin-left:200px
    3. 解决外边距垂直方向重合问题
        - 兄弟元素之间的外边距，在垂直方向上会取最大值而不是取和，可以通过触发BFC来防止它们之间相互影响
        - 比如为其中一个元素增加一个父元素，并触发父元素BFC，如overflow:hidden这样就不会重叠了

> flex布局 (简单的说几个常用的)

- 又称"弹性布局"
    - 容器设置display:flex;
    - 属性
        - justify-content
            1. flex-start （默认值） 左对齐
            2. flex-end 右对齐
            3. center 居中
            4. space-between 两端对齐，如果是三个及以上的盒子之间的间隔都相等
            5. space-around 两侧的会有间隔，内部间隔比两侧的间隔大一倍
        - align-items
            - center 上下居中 （配合着justify-content:center属性做垂直居中）
        - flex-wrap属性 控制是否换行
    - 其他属性参考 [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html "Flex 布局教程：语法篇")

> rem、em、px

- rem
    - 根据html的font-size属性的值 进行计算 1rem = html的font-size
- em
    - 根据当前对象内font-size属性的值 进行计算 1em = 当前对象内font-size
- px
    - 像素。相对于显示器屏幕分辨率


> less、sass/scss

- 都是动态样式语言 css的超集
- 变量符不一样，Less是@，而Scss是$
- 编译环境不一样。Sass的安装需要Ruby环境，是在服务端处理的，Less 可以运行在 Node 或浏览器端
- Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。

> 为什么用sass或less？

- 有动态语言的特性，可以定义变量、运算等
- 结构清晰，便于扩展
- 可以实现继承
- 完全兼容css代码

> 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？

- 标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin
- 低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin

> CSS优先级算法如何计算？

- 元素选择符： 1
- class选择符： 10
- id选择符：100
- 元素标签：1000
- !important声明的样式优先级最高，如果冲突再进行计算。
- 如果优先级相同，则选择最后出现的样式。
- 继承得到的样式的优先级最低。

> display有哪些值？

- display: inline 内联
- display: none 隐藏
- display: block 块元素
- display: table 表格显示
- display: list-item 项目列表
- display: inline-block 行内元素

> position的值

- static（默认）：按照正常文档流进行排列；
- relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；
- absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；
- fixed(固定定位)：所固定的参照对像是可视窗口。

> css实现三角形

```css
    div{
        width: 0;
        height: 0;
        border-top: 40px solid transparent;
        border-left: 40px solid transparent;
        border-right: 40px solid transparent;
        border-bottom: 40px solid #ff0000;
    }
```

> 文字溢出实现...的效果

```css
    // 单行溢出
    div{
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        width: 90%;
    }
    // 多行溢出
    div{
        overflow: hidden;  
        text-overflow: ellipsis;  
        display: -webkit-box;  
        -webkit-line-clamp: 3;  
        -webkit-box-orient: vertical;
    }
```

> display:none与visibility：hidden的区别？

- display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）
- visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）

> Chrome浏览器默认字体大小是多少？怎么让浏览器支持小于12px的文字

- 默认大小是16px
- 让浏览器支持小于12px的字体，可以设置缩放 transform:scale(0.8)

> css3 新增的属性

- 圆角 border-radius
- 阴影 box-shadow
- 文字阴影 text-shadow
- 线性渐变 gradient
- 动画 transform
    - rotate 旋转
    - scale 缩放
    - translate 定位
    - skew 倾斜
- 背景等等

> 伪类和伪元素

- 伪类单冒号
   - p:first-of-type    选择属于其父元素的首个 p 元素的每个 p 元素。
   - p:last-of-type    选择属于其父元素的最后 p 元素的每个 p 元素。
   - p:only-of-type    选择属于其父元素唯一的 p 元素的每个 p 元素。
   - p:only-child    选择属于其父元素的唯一子元素的每个 p 元素。
   - p:nth-child(2)    选择属于其父元素的第二个子元素的每个 p 元素。
   - :enabled  :disabled 控制表单控件的禁用状态。
   - :checked        单选框或复选框被选中。
- 伪元素双冒号

## javascript

> 什么是原型

- 对象的 `__proto__` 属性指向原型

> 什么是原型链

- 就是多个对象通过 `__proto__` 的方式连接了起来

> object.prototype的属性和方法

- Object.defineProperty(parame)方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。
- Object.hasOwnProperty(parame)方法用来判断某个对象是否含有指定的自身属性。
- Object.toString()将对象转换为字符串,不同类型的对象可能会重写自己的toString方法
    - `[1,2,3].toString() // 1,2,3`  Array包含的元素使用逗号连接起来组成字符串并返回
    - Date的toString方法会返回Date的时间字符串等
    - 普通object类型对象会返回[object Object]

> js原始类型

- boolean
- null
- undefined
- number
- string
- symbol
    - 功能类似于一种标识唯一性的ID
        ```javascript
            let s1 = Symbol()
            let s2 = Symbol('another symbol')
            let s3 = Symbol('another symbol')

            s1 === s2 // false
            s2 === s3 // false
        ```
    - 使用Symbol来作为对象属性名(key)
        ```javascript
            const PROP_NAME = Symbol()
            const PROP_AGE = Symbol()

            let obj = {
            [PROP_NAME]: "一斤代码"
            }
            obj[PROP_AGE] = 18

            obj[PROP_NAME] // '一斤代码'
            obj[PROP_AGE] // 18
        ```
    - typeof检查时返回的是symbol

> 对象（Object）类型

- 对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

> typeof 是否能正确判断类型？

- typeof 对于原始类型来说，除了 null 都可以显示正确的类型
    ```javascript
        typeof 1 // 'number'
        typeof '1' // 'string'
        typeof undefined // 'undefined'
        typeof true // 'boolean'
        typeof Symbol() // 'symbol'
    ```
- typeof 对于对象来说，除了函数都会显示 object
    ```javascript
        typeof [] // 'object'
        typeof {} // 'object'
        typeof console.log // 'function'
    ```

> instanceof 能正确判断对象的原理是什么？

- 内部机制是通过原型链来判断的

> this

- 对于直接调用函数，不管函数放在哪，this一定是window
- 对于对象.函数来说，谁调用了函数，谁就是this。
- 对于new来说，this永远绑定在实例上。
- 箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this
- 给函数bind或apply或call几次，this永远由第一次bind或apply或call决定
    - this 取决于第一个参数
    - 如果第一个参数为空，那么就是 window

> == vs ===

- == 
    - 如果对比的双方不一样的话，就会进行类型转换
    - boolean会转换成1或0
    - 对象会转换成原始类型 如转换成'[object Object]'
- 如果比较的是值类型，那么“==”比较其值；“===”比较其类型与值
- 如果是引用类型，那么比较的都是地址

> 闭包

- 什么是闭包
    - 函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
    - 闭包存在的意义就是让我们可以间接访问函数内部的变量。

> 深浅拷贝

- 浅拷贝 (浅拷贝只解决了第一层的问题)
    - object.assign
        ```javascript
            let a = {
                age: 1
            }
            let b = object.assign({},a)
            b.age = 2
            console.log(a.age) // 1
        ```
    - 扩展运算符`...`
        ```javascript
            let a = {
                age: 1
            }
            let b = { ...a }
            b.age = 2
            console.log(a.age) // 1
        ```
- 深拷贝
    - JSON.parse(JSON.stringify(object)) 
    - 递归

## es6+

> es6模块化如何使用，开发环境如何打包

- 模块化的基本语法
    ```javascript
        // util1.js
        export default {
            a: 100
        }
        
        // util2.js
        export function fn1(){
            alert('fn1)
        }
        export function fn2(){
            alert('fn2)
        }

        // index.js
        import util1 from './util1.js'
        import { fn1, fn2 } from './util2.js'
        console.log(util1)
        fn1()
        fn2()
    ```
- 开发环境配置
    - babel
    - webpack
    - rollup
    
> 关于js众多模块化标准

- AMD成为标准，require.js（也有CMD）
- 前端打包工具，nodejs模块化可以被使用
- ES6出现，想统一现在所有模块化标准

> class和普通构造函数有何区别

- js普通构造函数
    ```javascript
        function MathHandle(x, y) {
            this.x = x
            this.y = y
        }
        
        MathHandle.prototype.add = function () {
            return this.x + this.y
        }

        var m = new MathHandle(1, 2)
        console.log(m.add())
    ```
- class语法
    ```javascript
        class MathHandle {
            constructor(x, y) {
                this.x = x
                this.y = y
            }
            add() {
                return this.x + this.y
            }
        }

        const m = new MathHandle(1, 2)
        console.log(m.add())

        typeof MathHandle // 'function'
        MathHandle.prototype.constructor === MathHandle // true
        m.__proto__ === MathHandle.prototype // true
    ```
- 继承-js
    ```javascript
        // 动物
        function Animal() {
            this.eat = funtion () {
                console.log('Anima eat')
            }
        }

        // 狗
        function Dog() {
            this.bark = funtion () {
                console.log('Dog bark')
            }
        }

        // 绑定原型，实现继承
        Dog.prototype = new Animal()
        
        var hashiqi = new Dog()
        hashiqi.bark()
        hashiqi.eat()
    ```
- 继承-class
    ```javascript
        class Animal {
            constructor(name) {
                this.name = name
            }
            eat() {
                console.log(this.name + ' eat')
            }
        }
        
        class Dog extends Animal {
            constructor(name) {
                super(name) // 注意  继承的constructor
                this.name = name
            }
            say() {
                console.log(this.name + ' say')
            }
        }

        const dog = new Dog('哈士奇')
        dog.say()
        dog.eat()
    ```
- 总结
    - class在语法上更加贴合面向对象的写法
    - class实现继承更加易读、易理解
    - 更易于写java等后端语言的使用
    - 本质还是语法糖，使用prototype

> promise的基本使用

- Callback Hell
    ```javascript
        function loadImg(src, callback, fail) {
            var img = document.createElement('img')
            img.onload = function () {
                callback(img)
            }
            img.onerror = function () {
                fail()
            }
            img.src = src
        }
        var src = 'https://www.imooc.com/static/img/index/logo.png'
        loadImg(src, function(img){
            console.log(img.width)
        }, function() {
            console.log('failed')
        })
    ```
- Promise语法
    ```javascript
        function loadImg(src) {
            const promise = new Promise(function(resolve, reject) {
                var img = document.createElement('img')
                img.onload = function () {
                    resolve(img)
                }
                img.onerror = function () {
                    reject()
                }
                img.src = src
            })
            return promise
        }

        var src = 'https://www.imooc.com/static/img/index/logo.png'
        var result = loadImg(src)

        result.then(function(img) {
            console.log(img.width)
        }, function() {
            console.log('failed')
        })
    ```
- 总结
    - new Promise 实例，而且要return
    - new Promise 时要传入函数，函数有resolve，reject两个参数
    - 成功时执行resolve() 失败时执行reject()
    - then监听结果

> 总结一下es6其他常用功能

- let/const
    ```javascript
        let i = 20;
        i = 200;
        const j = 20;
        // j = 200  报错  常量不能再赋值
    ```
- 多行字符串/模板变量
    ```javascript
        let name = 'zhangsan', age = 20;
        const html = `
                <div>
                    <p>${name}</p>
                    <p>${age}</p>
                </div>
            `;
    ```
- 解构赋值
    ```javascript
        const obj = {a: 100, b: 200}
        const {a, b} = obj
        const arr = ['xxx', 'yyy', 'zzz']
        const [x, y, z] = arr
    ```
- 块级作用域
    ```javascript
        const obj = {a: 100, b: 200}
        for (let item in obj){
            console.log(item)
        }
        // console.log(item) 访问不到
    ```
- 函数默认参数
    ```javascript
        function fn(a, b=0){

        }
    ```
- 箭头函数
    ```javascript
        const arr = [1, 2, 3]
        arr.map(itme => item + 1)
        arr.map((item, index) => {
            console.log(item)
            return item + 1
        })
    ```
    ```javascript
        function fn() {
            console.log('real', this) // real {a: 100}

            var arr = [1, 2, 3]
            arr.map(function (item) {
                console.log(this) // window
            })

            arr.map(item => {
                console.log(this) // {a: 100}
            })
        }
        fn.call({a: 100})
    ```

## 异步

> 什么是单线程，和异步的关系

- 单线程 - 只有一个线程，只能做一件事
    ```javascript
        // 循环运行期间，JS 执行和 DOM 渲染暂时卡顿
        var i, sum = 0;
        for(i = 0; i< 1000000000; i++){
            sum += i;
        }
        console.log(sum)

        // alert 不处理，JS 执行和 DOM 渲染暂时卡顿
        console.log(1)
        alert('hello')
        console.log(2)
    ```
- 原因 - 避免DOM渲染的冲突
    - 浏览器需要渲染DOM
    - js可以修改DOM结构
    - js执行的时候，浏览器DOM渲染会暂停
    - 两段js也不能同时执行（都修改DOM就冲突了）
    - webworker支持多线程，但是不能访问DOM
- 解决方案 - 异步
    ```javascript
        console.log(100)
        setTimeout(function () {
            console.log(200)  // 反正 1000ms 之后执行
        }, 1000)              // 先不管它，先让其他js代码运行  
        console.log(300)
        console.log(400)
    ```
    ```javascript
        console.log(100) 
        $.ajax({
            url: 'xxx',
            success: function (result) { // ajax 加载完才执行
                console.log(result)      // 先不管它，先让其他js代码运行 
            }
        })
        console.log(300)
        console.log(400)
    ```

> 什么是event-loop

- 文字解释
    - 事件轮询，js实现异步的具体解决方案
    - 同步代码，直接执行
    - 异步函数先放在异步队列中
    - 待同步函数执行完毕，轮询执行异步队列的函数
- 实例分析
    ```javascript
        setTimeout(function () {
            console.log(100)
        })
        console.log(200)
        /*
        // 主进程                    // 异步队列
        console.log(200)            function () {
                                        console.log(100)
                                    }
        */
    ```
    ```javascript
        setTimeout(function () {
            console.log(1)
        }, 100)
        setTimeout(function () {
            console.log(2)
        })
        console.log(3)

        /*
        // 主进程                      // 异步队列

        console.log(3)                // 立即被放入
                                        function(){
                                            console.log(2)
                                        }
                                        
                                        // 100ms 之后被放入
                                        function(){
                                            console.log(1)
                                        }
        */
    ```
    ```javascript
        $.ajax({
            url: 'xxx',
            success: function () {
                console.log('a')
            }
        })
        setTimeout(function () {
            console.log('b')
        }, 100)
        setTimeout(function () {
            console.log('c')
        })
        console.log('d')

        /*
        // 主进程                      // 异步队列

        console.log('d')              // 立即被放入
                                        function(){
                                            console.log('c')
                                        }
                                        
                                        // 100ms 之后被放入
                                        function(){
                                            console.log('b')
                                        }
                                        // ajax 加载成功后执行
                                        console.log('a')

                                        不知道ajax加载和100ms快，所以不确定ajax先执行还是100ms快
        */
    ```

> jquery的Deferred

- jquery 1.5之后ajax的改变
- 使用jquery Deferred
    ```javascript
        function waitHandle() {
            var dtd = $.Deferred()
            var wait = function (dtd) {
                var task = function () {
                    console.log('执行完成')
                    // 成功
                    dtd.resolve()
                    // 失败
                    //dtd.reject()
                }
                setTimeout(task, 2000)
                return dtd.promise()  // 注意，这里返回的是promise而不是直接返回 deferred对象
            }
            return wait(dtd)
        }

        var w = waitHandle()  // w接收的就是一个promise对象
        $.when(w)
            .then(function () {
                console.log('ok 1')
            },function () {
                console.log('err 1')
            })
            .then(function () {
                console.log('ok 2')
            },function () {
                console.log('err 2')
            })
        // w.reject() // 执行这句话会直接报错
    ```
- 开放封闭的原则
    - 对扩展开放，对开发封闭

> promise 的基本使用和原理

- 基础语法
    ```javascript
        function loadImg(src) {
            const promise = new Promise(function(resolve, reject) {
                var img = document.createElement('img')
                img.onload = function () {
                    resolve(img)
                }
                img.onerror = function () {
                    reject('图片加载失败')
                }
                img.src = src
            })
            return promise
        }

        var src = 'https://www.imooc.com/static/img/index/logo.png'
        var result = loadImg(src)

        result.then(function(img) {
            console.log(img.width)
            return img
        }, function() {
            console.log('failed')
        }).then(function(img) {
            console.log(img.height)
            return img
        }, function() {
            console.log('failed')
        })
    ```
- 异常捕获（error和reject都要考虑）
    ```javascript
        // 规定：then 只接受一个参数，最后统一用 catch 捕获异常
        result.then(function(img) {
            console.log(img.width)
            return img
        }).then(function(img) {
            console.log(img.height)
        }).catch(function (ex) {
            // 最后统一 catch
            console.log(ex)
        })
    ```
- 多个串联 - 链式执行
    ```javascript
        var src1 = 'https://www.imooc.com/static/img/index/logo.png'
        var result1 = loadImg(src1)
        var src2 = 'https://img.mukewang.com/5d79998b0001a15618720632.jpg'
        var result2 = loadImg(src2)

        // 链式操作
        result1.then(function (img) {
            console.log('第一个图片加载完成')
            return result2 // 重要！！！
        }).then(function (img) {
            console.log('第二个图片加载完成')
        }).catch(function (ex) {
            // 最后统一 catch
            console.log(ex)
        })
    ```
- promise.all 和 promise.race
    ```javascript
        // promise.all 接收一个 promise 对象的数组
        // 待全部完成之后，统一执行 success
        Promise.all([result1, result2])
            .then(datas => {
                // 接收到的 datas 是一个数组，依次包含了多个 promise返回的内容
                console.log(datas[0])
                console.log(datas[1])
            })
        
        // promise.race 接收一个包含多个 promise 对象的数组
        // 只要有一个完成，就执行 success
        Promise.race([result1, result2])
            .then(data => {
                // data 即最先执行完成的 promise 的返回值
                console.log(data)
            })
    ```
- promise标准
    - 状态变化
        - 三种状态：pending  fulfilled  rejected
        - 初始状态是 pending
        - pending变为fulfilled，或者pending变为rejected
        - 状态变化不可逆
    - then
        - promise实例必须实现then这个方法
        - then()必须可以接受两个函数作为参数
        - then()返回的必须是一个promise实例    

> async/await

- 用法
    - 使用 await ，函数必须用async标识
    - await后面跟的是一个promise实例
    - 需要babel-polyfill

    ```javascript
        import 'babel-polyfill'

        function loadImg(src) {
            const promise = new Promise(function(resolve, reject) {
                var img = document.createElement('img')
                img.onload = function () {
                    resolve(img)
                }
                img.onerror = function () {
                    reject('图片加载失败')
                }
                img.src = src
            })
            return promise
        }
        const src1 = 'https://www.imooc.com/static/img/index/logo.png'
        const src2 = 'https://img.mukewang.com/5d79998b0001a15618720632.jpg'

        const load = async function () {
            const result1 = await loadImg(src1)
            console.log(result1)
            const result2 = await loadImg(src2)
            console.log(result2)
        }
        load()
    ```

> Generator

- 原理比较复杂
- 不是异步的直接替代方式
- 有更好更简洁的解决方案async/await
- koa 从Generator改为async/await
```javascript
    // 除了return语句，还可以用yield返回多次
    // 也可以把异步变为同步
    function* getInitList() {
        // 写法
        const res = yield axios.get('')
        // 处理逻辑 
        ...
    }
```

## 手写代码

- 实现一个深拷贝（简易版）
    ```javascript
        function deepClone(obj) {
            // 判断是否是对象类型
            function isObject(o) {
                // 1.typeof o === 'object' || typeof o === 'function' 为true
                // 2.但是typeof判断null也是对象 所以不等于 typeof o !== null
                return (typeof o === 'object' || typeof o === 'function') && typeof o !== null
            }

            // 不是对象类型
            if (!isObject(obj)) {
                throw new Error('非对象')
            }

            // 是对象类型
            let isArray = Array.isArray(obj)
            let newObj = isArray ? [...obj] : {...obj} // 判断是数组还是对象
            
            // Reflect.ownKeys(newObj) 用于返回对象所有属性
            Reflect.ownKeys(newObj).forEach(key => {
                // 1.判断值是否是对象类型
                // 2.不是的话直接赋值
                // 3.是的话调用deepClone函数在执行一遍,直到不是对象类型
                newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
            })

            // 最后返回对象
            return newObj
        }
    ```

## 虚拟DOM (virtual dom)

> vdom是什么？为何会存在vdom

- 什么是vdom
    - virtual dom，虚拟DOM
    - 用js模拟DOM结构
    - DOM变化的对比，放在js层来做（图灵完备语言）
    - 提高重绘性能
- 为何会存在vdom
    - DOM操作是"昂贵"的，js运行效率高
    - 尽量减少DOM操作，而不是清空重新渲染
    - 将DOM对比操作放在js层，提高效率

> vdom的如何应用，核心api是什么

- 介绍snabbdom
    - 一个虚拟DOM库，专注于简单性，模块化，强大的功能和性能。
    ```html
        <div id="container"><div>
        <button id="btn-change">change</button>

        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js"></script>
        <script src="https://cdn.bootcss.com/snabbdom/0.7.3/h.js"></script>
        
        <script type="text/javascript">
            var snabbdom = window.snabbdom

            // 定义 pathch
            var pathch = snabbdom.init([
                snabbdom_class,
                snabbdom_props,
                snabbdom_style,
                snabbdom_eventlisteners
            ])

            // 定义 h
            var h = snabbdom.h

            var container = document.getElementById('container')

            // 生成 vnode
            var vnode = h('ul#list', {}, [
                h('li.item', {}, 'Item 1'),
                h('li.item', {}, 'Item 2')
            ])
            pathch(container, vnode)

            document.getElementById('btn-change').addEventListener('click',function () {
                // 生成 newVnode
                var newVnode = h('ul#list', {}, [
                    h('li.item', {}, 'Item 1'),
                    h('li.item', {}, 'Item B'),
                    h('li.item', {}, 'Item 3'),
                ])
                pathch(vnode, newVnode)
            })

        </script>
    ```
- 核心API
    - h函数
        - `h('<标签名>', {...属性...}, [...子元素...])`
        - `h('<标签名>', {...属性...}, '...')`
    - patch函数
        - `pathch(container, vnode)`
        - `pathch(vnode, newVnode)`

> 介绍一下diff算法

- 什么是diff算法
    - Linux 的 diff命令
    - git diff命令
- vdom为何用diff算法
    - DOM操作是"昂贵"的，因此尽量减少DOM操作
    - 找出本次DOM必须更新的节点来更新，其他的不更新
    - 这个"找出"的过程，就需要diff算法
- diff算法的实现流程
    - `pathch(container, vnode)`
        ```
            {
                tag: 'ul',
                attrs: {
                    id: 'list'
                },
                children: [
                    {
                        tag: 'li',
                        attrs: {
                            className: 'item'
                        },
                        children: ['Item 1']
                    }
                ]
            }
                    
            <ul id="list"> 
                <li class="item">Item 1</li>
            </ul>
        ```
        ```javascript
            // 实现
            function createElement(vnode){
                var tag = vnode.tag 
                var attrs = vnode.attrs || {}
                var children = vnode.children || []

                if(!tag){
                    return null
                }

                // 创建真实的 DOM 元素
                var elem = document.createElement(tag)
                // 属性
                var attrName
                for(attrName in attrs){
                    if(attrs.hasOwnProperty(attrName)){
                        // 给 elem 添加属性
                        elem.setAttribute(attrName, attrs[attrName]) 
                    }
                }
                // 子元素
                children.forEach(function (childVnode) {
                    // 给 elem 添加子元素
                    elem.appendChild(createElement(childVnode)) // 递归 
                })
                
                // 返回真实的 DOM 元素
                return elem
            }
        ```
    - `pathch(vnode, newVnode)`
        ```
            {
                tag: 'ul',
                attrs: { id: 'list' },
                children: [
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 1']
                    },
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 2']
                    }
                ]
            } 

            {
                tag: 'ul',
                attrs: { id: 'list' },
                children: [
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 1']
                    },
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 222']
                    },
                    {
                        tag: 'li',
                        attrs: { className: 'item' },
                        children: ['Item 3']
                    }
                ]
            } 
        ```
        ```javascript
            // 实现
            function updateChildren(vnode, newVnode) {
                var children = vnode.children || []
                var newChildren = newVnode.children || []

                children.forEach(function (childVnode, index) {
                    var newChildVnode = newChildren[index]
                    if(childVnode.tag === newChildVnode.tag){
                        // 深层次对比，递归
                        updateChildren(childVnode,newChildVnode)
                    } else {
                        // 替换
                        replaceNode(childVnode,newChildVnode)
                    }
                })  
            }

            function replaceNode(vnode, newVnode){
                var elem = vnode.elem // 真实的 DOM 节点
                var newElem = createElement(newVnode)

                // 替换
            }
        ```
    - 不仅仅是以上内容
        - 节点新增和删除
        - 节点重新排序
        - 节点属性、样式、事件绑定
        - 如何极致压榨性能
        - ......

## vue

> 说一下使用jquery和vue框架的区别

- 数据和视图的分离，解耦(开放封闭原则)
- 以数据驱动视图，只关心数据变化，DOM操作被封装

> 说一下对MVVM的理解

- MVC
    - MVC:主要分为三个部分
        - 视图（view）：用于用户界面
        - 控制器（controller）：用于业务逻辑
        - 模型（model）：用于数据保存
    - View传送指令到Controller，
    - Controller完成业务逻辑后，要求Model改变状态，
    - Model将新的数据发送到View，用户得到反馈 
- MVVM
    - MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。
        - Model层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；
        - View代表UI组件，它负责将数据模型转化成UI展现出来；
        - ViewModel是一个同步View和Model的对象。
    - 在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，Model和ViewModel之间的交互是双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反应到View上。
    - ViewModel通过双向数据绑定把View层和Model层连接了起来，而View和Model之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理。

> vue的三要素

- 响应式：vue如何监听到data的每个属性变化？
- 模板引擎：vue的模板如何被解析，指令如何处理？
- 渲染：vue的模板如何被渲染成html？以及渲染过程

> vue中如何实现响应式

- 什么是响应式
    - 修改data属性之后，vue立即监听到
    - data属性被代理到vm上
- Object.defineProperty
    ```javascript
        var obj = {}
        var _name = 'zhangsan'
        Object.defineProperty(obj, 'name', {
            get: function () {
                console.log('get', _name) // 监听
                return _name
            },
            set: function (newVal) {
                console.log('set', newVal) // 监听
                _name = newVal
            }
        })
    ```

> vue如何解析模板

- 模板是什么
    - 本质：字符串
    - 有逻辑，如v-if，v-for等
    - 与html格式很像，但有很大区别
    - 最终还要转换为html来显示
    - 模板最终必须转换成js代码，因为：
    - 有逻辑(v-if v-for)，必须用js才能实现(图灵完备)
    - 转换为html渲染页面，必须用js才能实现
    - 因此，模板最终要转换成一个js函数(render函数)
- render函数
    - with的用法
        ```javascript
            var obj = {
                name: 'zhangsan',
                age: 20,
                getAddress: function () {
                    console.log('beijing')
                }
            }

            function fn() {
                with(obj) {
                    console.log(name)
                    console.log(age)
                    getAddress()
                }
            }
            fn()
        ```
    - 模板中所有信息都包含在了render函数中
    - this即vm
    - price 即 this.price 即 vm.price 即 data 中的price
    - _c 即 this._c 即 vm._c
    ```html
        <div id="app">
            <p>{{ price }}</p>
        </div>
        <script>
            var vm = new Vue({
                el: 'app',
                data: {
                    price: 100
                }
            })

            // 以下是手写的 render 函数
            function render() {
                with(this) { // this 就是vm
                    return _c(
                        'div',
                        {
                            attrs: { 'id': 'app' }
                        },
                        [
                            _c('p', [ _v(_s(price)) ])
                        ]
                    )
                }
            }
            function render1() {
                return vm._c(
                    'div',
                    {
                        attrs: { 'id': 'app' }
                    },
                    [
                        vm._c('p', [ vm._v(vm._s(vm.price)) ])
                    ]
                )
            }
            // vm.price   100 就是值
            // vm._s   JSON.stringify  转换成字符串
            // vm._v   文本节点
            // vm._c  函数
        </script>
    ```
    ```html
        <div id="app">
            <div>
                <input v-model="title">
                <button v-on:click="add"></button>
            </div>
            <div>
                <ul>
                    <li v-for="item in list">{{item}}</li>
                </ul>
            </div>
        </div>
        <script type="text/javascript">
            // data 独立
            var data = {
                title: '',
                list: []
            }
            // 初始化 Vue 实例
            var vm = new Vue({
                el: '#app',
                data: data,
                methods: {
                    add: function () {
                        this.list.push(this.title)
                        this.title = ''
                    }
                }
            })
            // render 函数
            with(this) {
                return _c('div', {
                    attrs: {
                        "id": "app"
                    }
                }, [_c('div', [_c('input', {
                    directives: [{
                        name: "model",
                        rawName: "v-model",
                        value: (title),
                        expression: "title"
                    }],
                    domProps: {
                        "value": (title)
                    },
                    on: {
                        "input": function ($event) {
                            if ($event.target.composing) return;
                            title = $event.target.value
                        }
                    }
                }), 
                _v(" "), 
                _c('button', {
                    on: {
                        "click": add
                    }
                })]), 
                _v(" "), 
                _c(
                    'div', 
                    [
                        _c('ul', _l((list), function (item) {
                            return _c('li', [_v(_s(item))])
                        }), 0)
                    ]
                )])
            }
        </script>
    ```
    - v-model怎么实现的
        ```javascript
            _c('input', {
                directives: [{
                    name: "model",
                    rawName: "v-model",
                    value: (title),
                    expression: "title"
                }],
                domProps: {
                    "value": (title)
                },
                on: {
                    "input": function ($event) {
                        if ($event.target.composing) return;
                        title = $event.target.value
                    }
                }
            })
        ```
    - v-for怎么实现的
        ```javascript
            _c('ul',
                _l((list), function (item) {
                    return _c('li', [_v(_s(item))])
                })
            , 0)
        ```
- render函数与vdom
    - snabbdom的 h函数 与vue的 _c函数 基本是相似的
    - render函数执行之后，返回的是vnode
        ```javascript
            vm.update(vnode) {
                const prevVnode = vm._vnode
                vm._vnode = vnode
                if(!prevVnode) {
                    vm.$el = vm.__patch__(vm.$el, vnode)
                } else {
                    vm.$el = vm.__patch__(prevVnode, vnode)
                }
            }
            function updateComponent() {
                // vm._render 即 上面的 render 函数 ，返回 vnode
                vm._update(vm._render())
            }
        ```
        - updateComponent 中实现了 vdom 的patch
        - 页面首次渲染执行 updateComponent
        - data 中每次修改属性，执行 updateComponent

> vue的整个实现流程

- 第一步：解析模板成render函数
    - with的用法
    - 模板中的所有信息都被render函数包含
    - 模板中用到的data中的属性，都变成了js变量
    - 模板中的v-model v-for v-on都变成了js逻辑
    - render 函数返回vnode
- 第二步：响应式开始监听
    - Object.defineProperty
    - 将data的属性代理到vm上
- 第三步：首次渲染，显示页面，且绑定依赖
    - 初次渲染，执行 updateComponent，执行vm._render()
    - 执行render函数，会访问到vm.list和vm.title
    - 会被响应式的get方法监听到
        - 为何要监听get，直接监听set不行吗？
            - data中有很多属性，有些被用到，有些可能不被用到
            - 被用到的会走到get，不被用到的不会走到get
            - 未走到get中的属性，set的时候我们也无需关心
            - 避免不必要的重复渲染
    - 执行updateComponent，会走到vdom的patch方法
    - patch将vnode渲染成DOM，初次渲染完成
- 第四步：data属性变化，触发rerender
    - 修改属性，被响应式的set监听到
    - set中执行updateComponent
    - updateComponent重新执行vm._render()
    - 生成的vnode和prevVnode，通过patch进行对比
    - 渲染到html

## react 

> react 的生命周期

- 生命周期函数指在某一个时刻组件会自动调用执行的函数
- 组件初始化 initialization
    - 设置 props和state
- 组件的挂载 Mounting
    - componentWillMount
        - 在组件即将被挂载到页面的时刻自动执行
    - render
    - componentDidMount
        - 组件被挂载到页面之后，自动被执行
- 组件的更新 Updation
    - state更新时
        - shouldComponentUpdate
            - 组件被更新之前，它会自动被执行
            - retuen true会往下执行
            - return false不会往下执行
        - componentWillUpdate
            - 组件被更新之前，它会自动执行，但是它在shouldComponentUpdate之后
            - 如果shouldComponentUpdate返回true，它才执行
            - 如果返回false，这个函数就不会被执行了
        - render
        - componentDidUpdate
            - 组件更新完成之后，它会被执行
    - props更新时
        - componentWillReceiveProps
            - 一个组件要从父组件接收参数
            - 如果这个组件第一次存在于父组件中，不会执行
            - 如果这个组件之前已经存在于父组件中，才会执行
        - shouldComponentUpdate
            - 组件被更新之前，它会自动被执行
            - retuen true会往下执行
            - return false不会往下执行
        - componentWillUpdate
            - 组件被更新之前，它会自动执行，但是它在shouldComponentUpdate之后
            - 如果shouldComponentUpdate返回true，它才执行
            - 如果返回false，这个函数就不会被执行了
        - render
        - componentDidUpdate
            - 组件更新完成之后，它会被执行
- 组件的卸载 Unmounting
    - componentWillUnmount
        - 当这个组件即将从页面中剔除的时候，会被执行

> react 几个性能优化

- 避免重复渲染,判断是否让render函数执行
    ```javascript
        // 性能优化
        shouldComponentUpdate(nextProps, nextState) {
            // 对比数据是否相同，从而是否让render函数执行
            if (nextProps.content != this.props.content) {
                return true;
            } else {
                return false;
            }
        }
    ```
- 做循环时key的取值，尽量不要用index下标
    - 一般用item做为key值
    - 设置key值是为了虚拟dom做对比的时候，快速定位
- ajax请求放在componentDidMount里
- 当普通组件只有render函数时，用无状态组件定义
    - 无状态组件性能比普通组件好，因为普通组件要执行生命周期函数

> 单向数据流

- react 父组件向子组件传值是只读属性
- 一般修改父组件的数据是父组件向子组件传递父组件的一个方法让子组件调用，从而修改数据

> 说一下对组件化的理解

- 组件的封装
    - 视图
    - 数据
    - 变化逻辑(数据驱动视图变化)
- 组件的复用
    - props传递
    - 复用

> JSX本质是什么

- JSX语法
    - html形式
    - 引入js变量和表达式
    - if...else...
    - 循环
    - style和className
    - 事件
- JSX解析成js
    - React.createElement 参数说明
        ```javascript
            // React.createElement 参数说明
            React.createElement('div', {id: 'div1'}, child1, child2, child3)
            React.createElement('div', {id: 'div1'}, [...])
        ```
    - 解析
        ```jsx
            /* JSX 代码 */
            var profile = <div>
                            <img src="avatar.png" className="profile"/>
                            <h3> {[user.firstName, user.lastName].join(' ')}</h3>
                          </div>;

            // 解析结果
            var profile = React.createElement("div", null,
                React.createElement("img", { src:"avatar.png" className: "profile"}),
                React.createElement("h3", null, [user.firstName, user.lastName].join(' '))
            )
        ```
    - JSX其实是语法糖
    - 开发环境会将JSX编译成js代码
    - JSX的写法大大降低了学习成本和编码工作量
    - 同时，JSX也会增加debug成本
- 独立的标准
    - JSX是React引入的，但不是React独有的
    - React已经将它作为一个独立标准开放，其他项目也可用
    - React.createElement是可以自定义修改的
    - 说明：本身功能已经具备；和其他标准兼容和扩展性没问题

> JSX和vdom的关系

- 分析：为何需要vdom
    - vdom是React初次推广开来的，结合JSX
    - JSX就是模板，最终要渲染成html
    - 初次渲染+修改state后的re-render
    - 正好符合vdom的应用场景
- React.createElement和h
    ```jsx
            /* JSX 代码 */
            var profile = <div>
                            <img src="avatar.png" className="profile"/>
                            <h3> {[user.firstName, user.lastName].join(' ')}</h3>
                          </div>;

            // 解析结果
            var profile = React.createElement("div", null,
                React.createElement("img", { src:"avatar.png" className: "profile"}),
                React.createElement("h3", null, [user.firstName, user.lastName].join(' '))
            )


            // h函数
            var vnode = h("div", null,
                h("img", { src:"avatar.png" className: "profile"}),
               h("h3", null, [user.firstName, user.lastName].join(' '))
            )
        ```
- 何时patch？
    - 初次渲染 - `ReactDOM.render(<App/>, container)`
    - 会触发patch(container, vnode)
    - re-render - `setState`
    - 会触发patch(vnode, newVnode)
- 自定义组件的解析
    - 自定义组件要用render返回
    - new 自定义组件

> 说一下setState的过程

- setState的异步
    - setState为何需要异步
        - 可能会一次执行多次setState
        - 你无法规定、限制用户如何使用setState
        - 没必要每次setState都重新渲染，考虑性能
        - 即便是每次重新渲染，用户也看不到中间的效果
        - 只看到结果即可
- vue修改属性也是异步
    - set中执行updateComponent  是异步的
- setState的过程
    - 每个组件实例，都有renderComponent方法
    - 执行renderComponent会重新执行实例的render
    - render函数返回newVnode，然后拿到preVnode
    - 执行patch(proVnode, newVnode)

> 阐述自己对react和vue的认识

- 两者的本质区别
    - vue - 本质是MVVM框架，由MVC发展而来
    - React - 本质是前端组件化框架，由后端组件化发展而来
    - 但这并不妨碍他们两者都能实现相同的功能
- 模板的区别
    - vue - 使用模板(最初由angular提出)
    - React - 使用JSX
    - 模板语法上，我更加倾向于JSX
        ```html
            // vue
            <div>
                <p v-if="ok">YES</p>
                <p v-else>NO</p>
            </div>

            // react
            <div>
                { ok ? <p>YES</p> : <p>NO</p> }
            </div>
        ```
    - 模板分离上，我更加倾向于vue
        - react 模板和js混在一起，未分离
- 组件化的区别
    - React本身就是组件化，没有组件化就不是React
    - vue也支持组件化，不过是在MVVM上的扩展
- 两者共同点
    - 都支持组件化
    - 都是数据驱动视图
- 如何选择
    - 国内使用，首推vue。文档更易读、易学、社区够大
    - 如果团队水平较高，推荐使用react。组件化和JSX

## webpack

> webpack.config.js

```javascript
    module.exports = {
        // 入口文件
        entry: './src/index.js',
        // 出口文件
        output: {
            path: __dirname,
            filename: './build/bundle.js'
        },
        // 加载器
        module: {
            rules: [
                {
                    test: /\.js?$/,
                    exclude: /(node_modules)/,
                    loader: 'babel-loader'
                }
            ]
        }
    }
```

## 小程序

> 原生微信小程序

> uni-app

> taro (后续会学。。。)

## hybrid

> hybrid是什么，为何用hybrid？

- hybrid文字解释
    - hybrid即"混合"，即前端和客户端的混合开发
    - 需前端开发人员和客户端开发人员配合完成
    - 某些环节也可能涉及到server端
- 存在价值，为何会用hybrid
    - 可以快速迭代更新
    - 体验流畅
    - 减少开发和沟通成本，双端公用一套代码
- webview
    - 是app中的一个组件(app可以有webview，也可以没有)
    - 用于加载h5页面，即一个小型的浏览器内核
- file:// 协议
    - file协议：本地文件，快
    - http(s)协议：网络加载，慢
- hybrid实现流程
    - 不是所有场景都适合使用hybrid
    - 使用NA(原生)：体验要求极致，变化不频繁(如头条的首页)
    - 使用hybrid：体验要求高，变化频繁(如头条的新闻详情页)
    - 使用h5：体验无要求，不常用(如举报、反馈等页面)
    - 具体实现
        - 前端做好静态页面(html js css)，将文件交给客户端
        - 客户端拿到前端静态页面，以文件形式存储在app中
        - 客户端在一个webview中
        - 使用file协议加载静态页面
        
> 介绍一下hybrid更新和上线的流程

- hybrid更新
    - 要替换每个客户端的静态文件
    - 只能客户端来做
    - 客户端去server下载最新的静态文件
    - 我们维护server的静态文件
- 完整流程
    - 分版本，有版本号，如201803211015
    - 将静态文件压缩成zip包，上传到服务端
    - 客户端每次启动，都去服务端检查版本号
    - 如果服务端版本号大于客户端版本号，就去下载最新的zip包
    - 下载完之后解压包，然后将现有文件覆盖

> hybrid和h5的主要区别

- 优点
    - 体验更好，更NA体验基本一致
    - 可快速迭代，无需app审核
- 缺点
    - 开发成本高。联调、测试、查bug都比较麻烦
    - 运维成本高。
- 适用的场景
    - hybrid：产品的稳定功能，体验要求高，迭代频繁
    - h5：单次的运营活动(如xx红包)或不常用功能

> 前端js和客户端如何通讯?

- 新闻详情页适用hybrid，前端如何获取新闻内容?
    - 不能用ajax获取。第一跨域，第二速度慢
    - 客户端获取新闻内容，然后js通讯拿到内容，再渲染
- js和客户端通讯的基本形式
    - js访问客户端能力，传递参数和回调函数
    - 客户端通过回调函数返回内容
- schema协议简介和使用
    - schema协议 - 前端和客户端通讯的约定
    - 使用
        ```javascript
            /* 以下是演示，无法正常运行，微信有严格的权限验证，外部页面不能随意使用 schem */
            var iframe = document.createElement('iframe')
            iframe.style.display = 'none'
            iframe.src = 'weixin://dl/scan' // 扫一扫 //ifram 访问 schema  
            var body = document.body || document.getElementsByTagName('body')[0]
            body.appendChild(iframe)
            setTimeout(function() {
                body.removeChild(iframe) // 销毁 iframe
                iframe = null
            })

            /* 如果要加上参数和 callback，那么就要这么写 */
            window['_weixin_scan_callback'] = function (result) {
                alert(result)
            }
            var iframe = document.createElement('iframe')
            iframe.style.display = 'none'
            iframe.src = 'weixin://dl/scan?k1=va&k2=v2&k3=v3&callback=_weixin_scan_callback'
            var body = document.body || document.getElementsByTagName('body')[0]
            body.appendChild(iframe)
            setTimeout(function() {
                body.removeChild(iframe) // 销毁 iframe
                iframe = null
            })
        ```
- schema使用的封装
    ```javascript
        (function(window, undefined) {

            // 调用 schema 的封装
            function _invoke(action, data, callback) {
                // 拼装 schema 协议
                var schema = 'myapp://utils/' + action

                // 拼接参数
                schema += '?a=a'
                var key 
                for(key in data) {
                    if(data.hasOwnProperty(key)) {
                        schema += '&' + key + data[key]
                    }
                }

                // 处理callback
                var callbackName = ''
                if(typeof callback === 'string') {
                    callbackName = callback
                } else {
                    callbackName = action + Date.now()
                    window[callbackName] = callback
                }
                schema += 'callback=callbackName'

                // 触发
                var iframe = document.createElement('iframe')
                iframe.style.display = 'none'
                iframe.src = schema
                var body = document.body || document.getElementsByTagName('body')[0]
                body.appendChild(iframe)
                setTimeout(function() {
                    body.removeChild(iframe) // 销毁 iframe
                    iframe = null
                })
            }
            
            // 暴露到全局变量
            window.invoke = {
                share: function (data, callback) {
                    _invoke('share', data, callback)
                },
                scan: function (data, callback) {
                    _invoke('scan', data, callback)
                },
                login: function (data, callback) {
                    _invoke('login', data, callback)
                },
            }
        })(window)
    ```
- 内置上线
    - 将以上封装的代码打包，叫做invoke.js，内置到客户端
    - 客户端每次启动webview，都默认执行invoke.js
    - 本地加载，免去网络加载的时间，更快。
    - 本地加载，没有网络请求，黑客看不到schema协议，更安全

## web存储

> cookie

> localStorage

> sessionStorage

## 设计模式 (常用的几个)

> 工厂模式

> 单例模式

> 适配器模式

> 装饰模式

> 代理模式

> 发布-订阅模式

> 外观模式

## 算法题

## 浏览器相关的一些问题

> 浏览器内核

> 输入 URL 到页面渲染的整个流程

> 浏览器的缓存机制

> 浏览器渲染原理

## 了解数据结构

> 时间复杂度和空间复杂度

> 排序

> 二叉树
